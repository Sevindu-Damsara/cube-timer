<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rubik's Cube Timer - Cubically AI Edition</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <!-- Cubing.js for 3D scramble visualization - Using the recommended twisty player module -->
    <script src="https://cdn.cubing.net/v0/js/cubing/twisty" type="module"></script>
    <style>
        /* Custom CSS for a modern, colorful look */
        /* BASE STYLES: These apply by default, effectively serving as the DESKTOP-FIRST layout. */
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color-primary, #0f172a); /* Dark blue-gray background */
            color: var(--text-color-primary, #e2e8f0); /* Light text color */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-y: auto; /* Allow scrolling for content */
            padding: 20px; /* Desktop padding */
            position: relative; /* Needed for positioning absolute children */
        }

        .container {
            background-color: var(--bg-color-secondary, #1e293b); /* Slightly lighter dark blue-gray */
            border-radius: 1.5rem; /* Large rounded corners */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            max-width: 1200px; /* Desktop max-width */
            width: 90%; /* Desktop relative width */
            padding: 2.5rem; /* Desktop padding */
            display: flex;
            flex-direction: column;
            gap: 2rem; /* Desktop gap */
            position: relative;
        }

        .timer-display {
            font-size: 6rem; /* Desktop font size for timer */
            font-weight: 700;
            color: var(--timer-color, #818cf8);
            text-shadow: 0 0 15px rgba(129, 140, 248, 0.6);
            letter-spacing: -0.05em;
            margin-bottom: 1rem;
        }

        .timer-display.inspection {
            color: #fbbf24; /* Amber for inspection */
        }

        .timer-display.ready {
            color: #22c55e; /* Green when ready */
        }

        .button-primary {
            background: linear-gradient(145deg, #6366f1, #818cf8); /* Gradient button */
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem; /* Base for desktop */
        }

        .button-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(99, 102, 241, 0.6);
        }

        .button-primary:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(99, 102, 241, 0.3);
        }

        .button-secondary {
            background-color: var(--button-secondary-bg, #475569); /* Slate gray */
            color: var(--button-secondary-text, #e2e8f0);
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 3px 10px rgba(71, 85, 105, 0.3);
            border: none;
            cursor: pointer;
            font-size: 1rem; /* Base for desktop */
        }

        .button-secondary:hover {
            background-color: var(--button-secondary-hover-bg, #64748b);
            transform: translateY(-1px);
        }

        .button-secondary:active {
            transform: translateY(0);
            box-shadow: 0 1px 5px rgba(71, 85, 105, 0.2);
        }

        .scramble-display {
            background-color: var(--card-bg, #334155); /* Darker slate */
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem; /* Desktop font size */
            font-weight: 500;
            color: var(--scramble-color, #a78bfa); /* Light purple */
            text-align: center;
            word-break: break-all;
        }

        /* 3D Cube Container Styling */
        #cube3DContainer {
            background-color: var(--bg-color-primary);
            border-radius: 0.75rem;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 300px; /* Desktop height */
            width: 100%;
            overflow: hidden;
            position: relative;
        }

        /* Twisty player needs a height */
        #scramble3DViewer {
            height: calc(100% - 60px);
            width: 100%;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Desktop grid layout */
            gap: 1rem;
        }

        .stat-card {
            background-color: var(--card-bg, #334155);
            padding: 1rem;
            border-radius: 0.75rem;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .stat-card .value {
            font-size: 1.8rem; /* Desktop font size */
            font-weight: 700;
            color: var(--stats-value-color, #67e8f9); /* Cyan */
            margin-top: 0.5rem;
        }

        .solve-history-item {
            background-color: var(--card-bg, #334155);
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            margin-bottom: 0.75rem;
            display: flex; /* Default to row for desktop */
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease-in-out;
            flex-wrap: nowrap; /* Prevent wrapping on desktop */
            gap: 1rem; /* Desktop gap */
        }

        .solve-history-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .solve-history-item .time {
            font-size: 1.2rem; /* Desktop font size */
            font-weight: 600;
            color: var(--solve-time-color, #a78bfa);
        }

        .solve-history-item .penalty-buttons {
            display: flex;
            gap: 0.5rem; /* Space between penalty buttons */
            flex-wrap: nowrap; /* Prevent wrapping on desktop */
            justify-content: flex-end;
            flex-grow: 1;
        }

        .solve-history-item .penalty-buttons button {
            background-color: #f87171; /* Red for DNF */
            color: white;
            padding: 0.3rem 0.7rem;
            border-radius: 0.375rem;
            font-size: 0.8rem;
            cursor: pointer;
            border: none;
            transition: background-color 0.2s;
        }
        .solve-history-item .penalty-buttons button.plus2 {
            background-color: #fbbf24; /* Amber for +2 */
        }
        .solve-history-item .penalty-buttons button.clear-penalty {
            background-color: #60a5fa; /* Blue for clear */
        }
        .solve-history-item .penalty-buttons button.delete {
            background-color: #dc2626; /* Strong red for delete */
            font-size: 0.9rem;
            padding: 0.4rem 0.8rem;
        }
        .solve-history-item .penalty-buttons button.insight-button {
            background-color: #4CAF50; /* Green for Insight */
            font-size: 0.9rem;
            padding: 0.4rem 0.8rem;
            box-shadow: 0 2px 5px rgba(76, 175, 80, 0.3);
        }
        .solve-history-item .penalty-buttons button.insight-button:hover {
            background-color: #45a049;
        }
        /* New Voice Command Button Styling */
        #voiceCommandBtn {
            background-color: #007bff; /* Blue */
            color: white;
            border-radius: 50%;
            width: 48px; /* Slightly larger touch target */
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem; /* Icon size */
            box-shadow: 0 4px 10px rgba(0, 123, 255, 0.4);
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
        }
        #voiceCommandBtn:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }
        #voiceCommandBtn:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0, 123, 255, 0.2);
        }
        #voiceCommandBtn.active {
            background-color: #dc3545; /* Red when active */
            animation: pulse-red 1s infinite;
        }

        @keyframes pulse-red {
            0% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(220, 53, 69, 0); }
            100% { box-shadow: 0 0 0 0 rgba(220, 53, 69, 0); }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal.open {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--bg-color-secondary, #1e293b);
            padding: 2rem; /* Desktop padding */
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            width: 90%; /* Desktop width */
            max-width: 500px; /* Desktop max-width */
            position: relative;
            color: var(--text-color-primary, #e2e8f0);
            max-height: 90vh; /* Prevent content from overflowing screen vertically */
            overflow-y: auto; /* Allow scrolling within modal if content is too long */
        }
        /* Specifically for AI Insight Modal to take more width on desktop */
        #aiInsightModal .modal-content {
            max-width: 700px; /* Wider for insight display */
        }


        .modal-close-button {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--text-color-primary, #e2e8f0);
            cursor: pointer;
        }

        .text-gradient {
            background: linear-gradient(90deg, #6366f1, #a78bfa, #f87171);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* MOBILE-SPECIFIC STYLES: These OVERRIDE desktop styles on smaller screens. */
        /* Targeting screens up to 767px wide (typical for most phones and small tablets) */
        @media (max-width: 767px) {
            body {
                padding: 16px; /* Reduced padding for mobile */
            }

            .container {
                padding: 1.5rem; /* Reduced padding for mobile */
                gap: 1.5rem; /* Reduced gap for mobile */
                max-width: 100%; /* Take full width on mobile */
                width: 100%;
            }

            .auth-corner-buttons {
                /* On mobile, stack buttons vertically and align to the right, inside the container flow */
                flex-direction: column;
                align-items: flex-end;
                margin-top: 0.5rem; /* Adjust to fit content well */
                margin-bottom: 0.5rem;
            }
            .auth-corner-buttons button {
                padding: 0.5rem 1rem; /* Slightly larger touch targets */
                font-size: 0.875rem; /* Slightly larger font for readability */
                width: auto; /* Allow buttons to size to content */
            }

            h1 {
                font-size: 2.5rem; /* Smaller heading for mobile */
                margin-bottom: 1rem; /* Adjusted margin */
            }

            .timer-display {
                font-size: 4rem; /* Smaller timer font for mobile */
                margin-bottom: 0.5rem;
            }

            .scramble-display {
                font-size: 1rem; /* Smaller scramble font for mobile */
                padding: 0.8rem 1rem; /* Adjusted padding */
            }

            #cube3DContainer {
                height: 250px; /* Adjusted height for mobile */
            }

            /* Control buttons flex-direction is already column for sm: (which is 640px)
               but we can specify here for max-width just to be explicit if needed */
            .flex-col.sm\:flex-row { /* Targeting the control buttons div */
                flex-direction: column;
                gap: 0.75rem; /* Adjusted gap */
            }
            .button-primary, .button-secondary {
                padding: 0.7rem 1.2rem; /* Ensure good touch target */
                font-size: 0.95rem; /* Slightly smaller font */
            }

            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); /* 2 columns on mobile, adjusts */
                gap: 0.8rem; /* Smaller gap for stats */
            }
            .stat-card {
                padding: 0.7rem; /* Adjusted padding */
            }
            .stat-card .value {
                font-size: 1.5rem; /* Smaller stat value font */
            }

            .solve-history-item {
                flex-direction: column; /* Stack time and buttons */
                align-items: flex-start; /* Align contents to start */
                gap: 0.5rem; /* Gap between time and buttons block */
                padding: 0.6rem 1rem; /* Smaller padding */
            }
            .solve-history-item .time {
                font-size: 1rem; /* Smaller time font */
                margin-bottom: 0; /* No bottom margin, flex gap handles it */
            }
            .solve-history-item .penalty-buttons {
                flex-wrap: wrap; /* Allow buttons to wrap */
                justify-content: flex-start; /* Align buttons to the left within their block */
                width: 100%; /* Take full width */
                margin-top: 0.25rem; /* Small margin above buttons when stacked */
                gap: 0.4rem; /* Smaller gap between penalty buttons */
            }
            .solve-history-item .penalty-buttons button {
                padding: 0.3rem 0.6rem; /* Smaller penalty buttons */
                font-size: 0.75rem;
            }
            .solve-history-item .penalty-buttons button.insight-button,
            .solve-history-item .penalty-buttons button.delete {
                padding: 0.35rem 0.7rem; /* Slightly larger for main action buttons */
                font-size: 0.8rem;
            }

            .modal-content {
                padding: 1.5rem; /* Adjusted padding for mobile modals */
                width: 95%; /* Fill almost full width */
                max-width: none; /* No max width on mobile */
                max-height: 90vh; /* Control vertical height */
                overflow-y: auto; /* Allow scrolling within modal */
            }
            /* Adjust AI Insight Modal for mobile */
            #aiInsightModal .modal-content {
                max-width: none; /* No max-width on mobile */
            }

            .modal-close-button {
                font-size: 1.75rem; /* Larger close button for touch */
                padding: 0.5rem; /* Increase touch area */
            }

            /* Adjustments within settings modal for smaller screens */
            .modal-content label {
                font-size: 0.95rem; /* Smaller label font */
            }
            .modal-content select, .modal-content input[type="text"], .modal-content input[type="email"], .modal-content input[type="password"] {
                padding: 0.6rem 0.8rem; /* Adjusted input padding */
                font-size: 0.9rem; /* Adjusted input font size */
            }
            .modal-content h3 {
                font-size: 1.1rem; /* Smaller subheading */
                margin-bottom: 0.75rem;
            }
            /* Voice Command Button Mobile Adjustments */
            #voiceCommandBtn {
                width: 44px;
                height: 44px;
                font-size: 1.3rem;
                position: fixed; /* Keep it fixed on screen */
                bottom: 20px;
                right: 20px;
                z-index: 100; /* Ensure it's above other content */
            }
        }

        /* Further specific adjustments for very small screens (e.g., iPhone SE) */
        @media (max-width: 479px) {
            .timer-display {
                font-size: 3rem; /* Even smaller timer font for very small screens */
            }
            h1 {
                font-size: 2rem; /* Even smaller heading for very small screens */
            }
            .scramble-display {
                font-size: 0.9rem; /* Even smaller scramble font */
            }
            .stat-card .value {
                font-size: 1.3rem; /* Even smaller stat value font */
            }
            .button-primary, .button-secondary {
                font-size: 0.9rem; /* Slightly smaller button font */
                padding: 0.6rem 1rem; /* Reduced padding */
            }
            .solve-history-item .penalty-buttons button {
                font-size: 0.7rem; /* Smallest penalty button font */
            }
        }


        /* Theme specific variables (kept same) */
        body.theme-dark {
            --bg-color-primary: #0f172a;
            --text-color-primary: #e2e8f0;
            --bg-color-secondary: #1e293b;
            --button-secondary-bg: #475569;
            --button-secondary-text: #e2e8f0;
            --button-secondary-hover-bg: #64748b;
            --card-bg: #334155;
            --timer-color: #818cf8;
            --scramble-color: #a78bfa;
            --stats-value-color: #67e8f9;
        }

        body.theme-light {
            --bg-color-primary: #f0f2f5;
            --text-color-primary: #333;
            --bg-color-secondary: #ffffff;
            --button-secondary-bg: #e2e8f0;
            --button-secondary-text: #333;
            --button-secondary-hover-bg: #cbd5e1;
            --card-bg: #f9fafb;
            --timer-color: #3b82f6;
            --scramble-color: #1d4ed8;
            --stats-value-color: #0ea5e9;
        }

        body.theme-vibrant {
            --bg-color-primary: #2d0b57;
            --text-color-primary: #f0f2f5;
            --bg-color-secondary: #4a148c;
            --button-secondary-bg: #8e24aa;
            --button-secondary-text: #f0f2f5;
            --button-secondary-hover-bg: #ab47bc;
            --card-bg: #6a1b9a;
            --timer-color: #e0f7fa;
            --scramble-color: #ce93d8;
            --stats-value-color: #80cbc4;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="theme-dark"> <!-- Set default theme class here -->
    <div class="container mx-auto rounded-3xl">
        <!-- Authentication Controls - Positioned at the top right, uses flex for responsiveness -->
        <div class="flex flex-wrap justify-end gap-2 text-sm auth-corner-buttons">
            <button id="signInBtn" class="button-primary">Sign In</button>
            <button id="signUpBtn" class="button-secondary">Sign Up</button>
            <button id="signOutBtn" class="button-secondary" style="display:none;">Sign Out</button>
        </div>

        <h1 class="text-4xl font-bold text-center text-gradient mb-6">Rubik's Cube Timer</h1>

        <!-- Username Display -->
        <div class="text-sm text-center text-gray-400">
            Current User: <span id="usernameDisplay" class="font-mono text-gray-300">Loading...</span>
        </div>

        <!-- Scramble Display (Text) -->
        <div id="scrambleTextDisplay" class="scramble-display" style="display: block;">
            Generating scramble...
        </div>

        <!-- 3D Cube Viewer Container (Initially hidden) -->
        <div id="cube3DContainer" style="display: none;">
            <!-- The twisty-player element for 3D visualization -->
            <twisty-player id="scramble3DViewer"
                visualization="3D"
                alg=""
                puzzle="3x3x3"
                style="width: 100%; height: 100%;"
                face-letters="false"
                control-panel="none" <!-- Important: Disable default controls for custom toolbar -->
                hint-arrows="none"             <!-- Added to hide hint arrows -->
                camera-latitude="15"           <!-- Set default camera angle -->
                camera-longitude="-45"         <!-- Set default camera angle -->
                background="#0f172a"           <!-- Set a default background color that matches dark theme -->
            ></twisty-player>
            <!-- Custom Toolbar -->
            <div id="customPreviewToolbar" class="absolute bottom-4 left-1/2 -translate-x-1/2 flex gap-4 p-2 bg-gray-800 bg-opacity:70 rounded-full shadow-lg z-10">
                <button id="playPreviewBtn" class="p-2 rounded-full bg-blue-500 hover:bg-blue-600 text-white flex items-center justify-center">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd"></path></svg>
                </button>
                <button id="pausePreviewBtn" class="p-2 rounded-full bg-yellow-500 hover:bg-yellow-600 text-white flex items-center justify-center">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd"></path></svg>
                </button>
                <button id="restartPreviewBtn" class="p-2 rounded-full bg-red-500 hover:bg-red-600 text-white flex items-center justify-center">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.188A7.001 7.001 0 0110 3a7 7 0 017 7 7 7 0 01-7 7 7 7 0 01-7-7c0-.203.011-.403.032-.601A1.505 1.505 0 003 9.5a.5.5 0 01-.5-.5.5.5 0 00-.5-.5A1.505 1.505 0 002 8.42V7a1 1 0 011-1V3a1 1 0 011-1zm6 13a5 5 0 100-10 5 5 0 000 10z" clip-rule="evenodd"></path></svg>
                </button>
            </div>
        </div>


        <!-- Timer Display -->
        <div id="timerDisplay" class="timer-display text-center">
            00:00.000
        </div>

        <!-- Control Buttons -->
        <div class="flex flex-col sm:flex-row justify-center gap-4">
            <button id="startStopBtn" class="button-primary flex-1">Start / Stop (Space)</button>
            <button id="resetBtn" class="button-secondary flex-1">Reset</button>
            <button id="scrambleBtn" class="button-secondary flex-1">New Scramble</button>
            <button id="settingsBtn" class="button-secondary flex-1">Settings</button>
        </div>

        <!-- Statistics -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="label text-gray-400">Best Time</div>
                <div id="bestTime" class="value">--:--.--</div>
            </div>
            <div class="stat-card">
                <div class="label text-gray-400">Ao5</div>
                <div id="ao5" class="value">--:--.--</div>
            </div>
            <div class="stat-card">
                <div class="label text-gray-400">Ao12</div>
                <div id="ao12" class="value">--:--.--</div>
            </div>
            <div class="stat-card">
                <div class="label text-gray-400">Solves</div>
                <div id="solveCount" class="value">0</div>
            </div>
        </div>

        <!-- Solve History -->
        <div>
            <h2 class="text-2xl font-semibold text-gradient mb-4">Solve History</h2>
            <div id="solveHistoryList" class="max-h-64 overflow-y-auto pr-2">
                <!-- Solve times will be dynamically added here -->
                <p class="text-center text-gray-500" id="noSolvesMessage">No solves yet. Start cubing!</p>
            </div>
        </div>

    </div>

    <!-- Floating Action Button for Voice Commands -->
    <button id="voiceCommandBtn" class="fixed bottom-6 right-6 z-50">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.25-2.52 5.8-5.3 5.8S6.7 14.25 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg>
    </button>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal" role="dialog" aria-modal="true" tabindex="-1">
        <div class="modal-content">
            <button class="modal-close-button" id="closeSettingsModal" aria-label="Close settings">&times;</button>
            <h2 class="text-2xl font-bold text-gradient mb-6">Settings</h2>
            <div class="flex flex-col gap-4">
                <div class="flex items-center justify-between">
                    <label for="inspectionToggle" class="text-lg">Enable 15s Inspection</label>
                    <input type="checkbox" id="inspectionToggle" class="w-6 h-6 rounded focus:ring-purple-500 transition duration-150 ease-in-out text-purple-600 form-checkbox bg-gray-700 border-gray-600">
                </div>

                <div class="flex items-center justify-between">
                    <label for="soundEffectsToggle" class="text-lg">Enable Sound Effects</label>
                    <input type="checkbox" id="soundEffectsToggle" class="w-6 h-6 rounded focus:ring-purple-500 transition duration-150 ease-in-out text-purple-600 form-checkbox bg-gray-700 border-gray-600">
                </div>

                <div class="flex items-center justify-between">
                    <label for="cubeTypeSelect" class="text-lg">Cube Type</label>
                    <select id="cubeTypeSelect" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-white">
                        <option value="3x3">3x3</option>
                        <option value="2x2">2x2</option>
                        <option value="4x4">4x4</option>
                        <option value="pyraminx">Pyraminx</option>
                    </select>
                </div>

                <div class="flex items-center justify-between">
                    <label for="themeSelect" class="text-lg">Theme</label>
                    <select id="themeSelect" class="bg-gray-700 border border-gray-600 rounded-lg p-2 text-white">
                        <option value="dark">Dark (Default)</option>
                        <option value="light">Light</option>
                        <option value="vibrant">Vibrant</option>
                    </select>
                </div>

                <!-- New: 3D Cube View Toggle -->
                <div class="flex items-center justify-between">
                    <label for="cubeViewToggle" class="text-lg">Show 3D Cube Scramble</label>
                    <input type="checkbox" id="cubeViewToggle" class="w-6 h-6 rounded focus:ring-purple-500 transition duration-150 ease-in-out text-purple-600 form-checkbox bg-gray-700 border-gray-600">
                </div>

                <div class="mt-4 pt-4 border-t border-gray-600">
                    <h3 class="text-xl font-semibold text-gradient mb-3">Change Username</h3>
                    <div class="mb-3">
                        <label for="settingsUsernameInput" class="block text-gray-300 text-sm font-bold mb-2">New Username:</label>
                        <input type="text" id="settingsUsernameInput" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-900 leading-tight focus:outline-none focus:shadow-outline bg-gray-200" placeholder="Enter new username">
                    </div>
                    <button id="saveUsernameBtn" class="button-primary w-full">Save Username</button>
                    <p id="usernameUpdateMessage" class="text-sm mt-2 text-center" style="display:none;"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div id="authModal" class="modal" role="dialog" aria-modal="true" tabindex="-1">
        <div class="modal-content">
            <button class="modal-close-button" id="closeAuthModal" aria-label="Close authentication modal">&times;</button>
            <h2 id="authModalTitle" class="text-2xl font-bold text-gradient mb-6 text-center">Sign In</h2>

            <div class="mb-4">
                <label for="email" class="block text-gray-300 text-sm font-bold mb-2">Email:</label>
                <input type="email" id="email" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-900 leading-tight focus:outline-none focus:shadow-outline bg-gray-200" placeholder="your@email.com">
            </div>
            <div class="mb-4" id="usernameFieldGroup" style="display:none;">
                <label for="usernameInput" class="block text-gray-300 text-sm font-bold mb-2">Username:</label>
                <input type="text" id="usernameInput" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-900 leading-tight focus:outline-none focus:shadow-outline bg-gray-200" placeholder="Enter your username">
            </div>
            <div class="mb-6">
                <label for="password" class="block text-gray-300 text-sm font-bold mb-2">Password:</label>
                <input type="password" id="password" class="shadow appearance-none border rounded-lg w-full py-2 px-3 text-gray-900 mb-3 leading-tight focus:outline-none focus:shadow-outline bg-gray-200" placeholder="********">
            </div>
            <p id="authError" class="text-red-500 text-sm mb-4" style="display:none;"></p>

            <div class="flex flex-col gap-3 mb-4">
                <button id="emailAuthBtn" class="button-primary w-full">Sign In</button>
                <button id="googleSignInBtn" class="button-secondary w-full flex items-center justify-center gap-2">
                    <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google logo" class="w-5 h-5">
                    Sign In with Google
                </button>
            </div>
        </div>
    </div>

    <!-- AI Insight Modal -->
    <div id="aiInsightModal" class="modal" role="dialog" aria-modal="true" tabindex="-1">
        <div class="modal-content">
            <button class="modal-close-button" id="closeAiInsightModal" aria-label="Close AI insight">&times;</button>
            <h2 class="text-2xl font-bold text-gradient mb-4">Solve Insight âœ¨</h2>
            <div id="aiInsightContent" class="text-gray-300 text-sm sm:text-base">
                <div class="spinner mx-auto my-4" style="display: none;"></div>
                <p id="insightMessage" class="text-center">Generating insight...</p>
                <div id="optimalSolutionDisplay" class="mt-4 p-3 bg-gray-700 rounded-lg" style="display: none;">
                    <h3 class="text-lg font-semibold text-gradient mb-2">Optimal Solution:</h3>
                    <p id="optimalSolutionText" class="font-mono text-white text-sm"></p>
                </div>
                <div id="personalizedTipDisplay" class="mt-4 p-3 bg-gray-700 rounded-lg" style="display: none;">
                    <h3 class="text-lg font-semibold text-gradient mb-2">Personalized Tip:</h3>
                    <p id="personalizedTipText" class="text-white text-sm"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        console.log("[DEBUG] Script execution started.");
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // Removed signInAnonymously from imports
        import { getAuth, onAuthStateChanged,
                 createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, orderBy, limit, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        console.log("[DEBUG] Firebase imports completed.");

        // =====================================================================================================
        // --- IMPORTANT: Firebase Firestore Security Rules (MUST BE SET IN FIREBASE CONSOLE) ---
        // To prevent "Missing or insufficient permissions" (400 Bad Request) errors from Firestore,
        // you MUST add these rules to your Firebase project's Firestore database rules.
        // Go to Firebase Console -> Firestore Database -> Rules tab, and REPLACE the content with this:
        /*
        rules_version = '2';
        service cloud.firestore {
          match /databases/{database}/documents {
            // Rule for private user data: Allows read/write only if the user is authenticated
            // and the 'userId' in the path matches their authenticated UID.
            // This now only applies to explicitly signed-in users.
            match /artifacts/{appId}/users/{userId}/{document=**} {
              allow read, write: if request.auth != null && request.auth.uid == userId;
            }
          }
        }
        */
        // =====================================================================================================

        // =====================================================================================================
        // --- IMPORTANT: Firebase Authentication Methods (MUST BE ENABLED IN FIREBASE CONSOLE) ---
        // To allow users to sign in (with email/password, or Google),
        // you MUST enable these sign-in providers in your Firebase project.
        // Go to Firebase Console -> Authentication -> Sign-in method tab.
        // - Ensure 'Email/Password' provider is enabled.
        // - Ensure 'Google' provider is enabled (if you intend to use Google Sign-In).
        // - IMPORTANT: The 'Anonymous' provider is no longer used by this client-side code.
        // =====================================================================================================


        // =====================================================================================================
        // --- IMPORTANT: Firebase Configuration for Hosting ---
        // REPLACE THE PLACEHOLDER VALUES BELOW WITH YOUR ACTUAL FIREBASE PROJECT CONFIGURATION.
        // You can find these in your Firebase project settings -> Project settings -> General -> Your apps -> Firebase SDK snippet (Config).
        // The API key you found: "AIzaSyBi8BkZJnpW4WI71g5Daa8KqNBI1DjcU_M" will now be accepted by the validation.
        //
        // NOTE: The geminiApiKey is handled by a serverless function for security.
        // You will need to deploy a Vercel Serverless Function for AI Insight.
        // =====================================================================================================
        const appId = 'my-production-speedcube-timer'; // A unique ID for your app's data in Firestore. e.g., 'rubik-timer-prod-v1'
        const firebaseConfig = {
            apiKey: "AIzaSyBi8BkZJnpW4WI71g5Daa8KqNBI1DjcU_M", // This is the key you found in your console.
            authDomain: "ubically-timer.firebaseapp.com",
            projectId: "ubically-timer",
            storageBucket: "ubically-timer.firebasestorage.app",
            messagingSenderId: "467118524389",
            appId: "1:467118524389:web:d3455f5be5747be2cb910c",
            measurementId: "G-6033SRP9WC"
        };
        // The URL for your deployed Vercel Serverless Function for AI insights.
        // This will be provided AFTER you deploy the function to Vercel and then updated here.
        const geminiInsightFunctionUrl = "https://cube-timer-ten.vercel.app/api/gemini-insight"; 
        // NEW: The URL for your deployed Vercel Serverless Function for Gemini NLU.
        // You will need to deploy api/gemini-nlu.py and update this URL.
        const geminiNluFunctionUrl = "https://cube-timer-ten.vercel.app/api/gemini-nlu"; // <<< IMPORTANT: Update this after deployment!
        // =====================================================================================================
        // --- END IMPORTANT CONFIGURATION ---
        // =====================================================================================================

        console.log(`[DEBUG] App ID: ${appId}`);
        // ADDED: Log the actual firebaseConfig object for debugging
        console.log("[DEBUG] firebaseConfig received:", JSON.stringify(firebaseConfig, null, 2));


        let app;
        let db; // Firestore instance
        let auth; // Auth instance
        let userId = null; // Will be Firebase UID or a local UUID for guests
        let isAuthReady = false; // Flag to indicate if Firebase auth state has been determined
        let domElementsReady = false; // New flag to indicate if all DOM elements are assigned
        let isUserAuthenticated = false; // NEW: True if user is signed in via Email/Google, false for guests/signed out


        // This function attempts to initialize user data and settings (Firestore listener, settings load).
        // It will only proceed if both `domElementsReady` AND `isAuthReady` are true.
        const initializeUserDataAndSettings = async () => {
            if (!domElementsReady) {
                 console.log("[DEBUG] Deferred initializeUserDataAndSettings: DOM not ready. Waiting.");
                 return;
            }
            if (!isAuthReady) {
                 console.log("[DEBUG] Deferred initializeUserDataAndSettings: Auth not ready. Waiting.");
                 return;
            }
            
            // NEW: Conditional initialization based on authentication status
            if (isUserAuthenticated && db && userId) {
                console.log("[DEBUG] Authenticated user. Proceeding with Firestore data initialization.");
                // Use a simple attribute flag on an element to prevent duplicate initialization
                if (solveHistoryList && !solveHistoryList.hasAttribute('data-initialized-firestore')) {
                    await loadUserSettings(); // This loads settings and calls applySettingsToUI
                    setupRealtimeSolvesListener(); // This sets up onSnapshot listener
                    solveHistoryList.setAttribute('data-initialized-firestore', 'true'); // Mark as initialized
                } else {
                    console.log("[DEBUG] Firestore user data/settings already initialized.");
                }
            } else { // Guest user (not authenticated via Email/Google)
                console.log("[DEBUG] Guest user. Proceeding with Local Storage data initialization.");
                // Use a simple attribute flag on an element to prevent duplicate initialization
                if (solveHistoryList && !solveHistoryList.hasAttribute('data-initialized-local')) {
                    loadLocalUserSettings(); // Load settings from local storage
                    loadLocalSolves();       // Load solves from local storage
                    renderSolveHistory();    // Render local solves
                    solveHistoryList.setAttribute('data-initialized-local', 'true'); // Mark as initialized
                } else {
                    console.log("[DEBUG] Local user data/settings already initialized.");
                }
            }
            // Ensure timer/scramble are reset/generated regardless of auth state
            resetTimer(); 
        };

        // Helper to check if Firebase config is valid (more robust than just checking for non-empty strings)
        function isFirebaseConfigValid(config) {
            // This function now only checks for basic presence, letting Firebase SDK handle deeper validity.
            return config && config.apiKey && config.authDomain && config.projectId;
        }

        // --- Firebase Initialization and Auth Listener ---
        // This block runs immediately when the script loads.
        // It sets up Firebase and the authentication listener.
        if (isFirebaseConfigValid(firebaseConfig)) { // Use the robust check here
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            console.log("[DEBUG] Firebase initialized. Setting up auth state listener.");

            onAuthStateChanged(auth, async (user) => {
                console.log("[DEBUG] onAuthStateChanged callback triggered. User:", user ? user.uid : "null");
                if (user && !user.isAnonymous) { // User is explicitly signed in (Email/Google)
                    userId = user.uid;
                    isUserAuthenticated = true; // Set flag
                    isAuthReady = true;

                    // Update UI for authenticated user (buttons can be accessed before general app init)
                    const signInBtn = document.getElementById('signInBtn');
                    const signUpBtn = document.getElementById('signUpBtn');
                    const signOutBtn = document.getElementById('signOutBtn');
                    if (signInBtn) signInBtn.style.display = 'none';
                    if (signUpBtn) signUpBtn.style.display = 'none';
                    if (signOutBtn) signOutBtn.style.display = 'inline-block';
                    console.log("[DEBUG] Auth UI updated for signed in user.");

                    await fetchAndDisplayUsername(user.uid, user.email, user.displayName);
                    console.log("[DEBUG] Username fetched and displayed.");

                    initializeUserDataAndSettings(); // Attempt to initialize user data/settings
                } else { // User is signed out (including if they were previously anonymous)
                    console.log("[DEBUG] User not authenticated (signed out). Initializing as Guest.");
                    userId = `guest-${crypto.randomUUID()}`; // Use a new local UUID for guest session
                    isUserAuthenticated = false; // Set flag
                    isAuthReady = true;

                    // Update UI for guest user
                    const usernameDisplayElement = document.getElementById('usernameDisplay');
                    // MODIFIED: Simplified Guest display
                    if (usernameDisplayElement) usernameDisplayElement.textContent = 'Guest'; 
                    const signInBtn = document.getElementById('signInBtn');
                    const signUpBtn = document.getElementById('signUpBtn');
                    const signOutBtn = document.getElementById('signOutBtn');
                    if (signInBtn) signInBtn.style.display = 'inline-block';
                    if (signUpBtn) signUpBtn.style.display = 'inline-block';
                    if (signOutBtn) signOutBtn.style.display = 'none';
                    console.log("[DEBUG] Auth UI updated for guest user.");

                    initializeUserDataAndSettings(); // Attempt to initialize in local storage mode
                }
            });
        } else {
            // Offline/guest mode (Firebase config missing or incomplete)
            console.warn("[DEBUG] Firebase config missing or incomplete. Running in offline/guest mode without persistent storage (solves will not be saved beyond session).");
            userId = `guest-${crypto.randomUUID()}`; // Fallback for no Firebase config/validity
            isUserAuthenticated = false; // Not authenticated
            isAuthReady = true; // Auth state determined (offline)
            
            const usernameDisplayElement = document.getElementById('usernameDisplay');
            // MODIFIED: Simplified Offline Guest display
            if (usernameDisplayElement) usernameDisplayElement.textContent = 'Guest (Offline Mode)'; 
            const signInBtn = document.getElementById('signInBtn');
            const signUpBtn = document.getElementById('signUpBtn');
            const signOutBtn = document.getElementById('signOutBtn');
            if (signInBtn) signInBtn.style.display = 'inline-block';
            if (signUpBtn) signUpBtn.style.display = 'inline-block';
            if (signOutBtn) signOutBtn.style.display = 'none';
            initializeUserDataAndSettings(); // Attempt to initialize in offline mode
        }

        /**
         * Function to fetch and display username from Firestore for authenticated users,
         * or set to "Guest" for local users.
         */
        async function fetchAndDisplayUsername(uid, email = null, displayName = null) {
            console.log(`[DEBUG] Entering fetchAndDisplayUsername for UID: ${uid}`);
            const usernameDisplayElement = document.getElementById('usernameDisplay');
            if (!usernameDisplayElement) {
                console.warn("[WARN] fetchAndDisplayUsername: usernameDisplayElement not found. Skipping username display.");
                return;
            }

            if (isUserAuthenticated && db && uid) { // Authenticated user, fetch from Firestore
                const userProfileRef = doc(db, `artifacts/${appId}/users/${uid}/profile/data`);
                try {
                    console.log(`[DEBUG] Attempting to get user profile from Firestore: ${userProfileRef.path}`);
                    const docSnap = await getDoc(userProfileRef);
                    let customUsername = null;

                    if (docSnap.exists() && docSnap.data().username) {
                        customUsername = docSnap.data().username;
                        console.log(`[DEBUG] User profile exists. Username: ${customUsername}`);
                    } else {
                        console.log("[DEBUG] User profile not found or no username. Generating default.");
                        let defaultUsername = displayName || (email ? email.split('@')[0] : 'User');
                        await setDoc(userProfileRef, { username: defaultUsername }, { merge: true });
                        console.log(`[DEBUG] Default username created and saved: ${defaultUsername}`);
                        customUsername = defaultUsername;
                    }
                    // MODIFIED: Removed "User: " prefix from authenticated display
                    usernameDisplayElement.textContent = `${customUsername}`; 
                    console.log(`[DEBUG] Username display updated to: ${usernameDisplayElement.textContent}`);

                } catch (e) {
                    console.error("[ERROR] Error fetching or setting username:", e);
                    // MODIFIED: Removed "User: " prefix from error fallback
                    usernameDisplayElement.textContent = `${uid} (Error fetching username)`; 
                }
            } else { // Guest user (local storage)
                // MODIFIED: Ensured it only sets 'Guest' directly
                usernameDisplayElement.textContent = 'Guest'; 
                console.log(`[DEBUG] Username display updated to: Guest (Local Mode)`);
            }
            console.log("[DEBUG] Exiting fetchAndDisplayUsername.");
        }


        // --- Timer Variables ---
        let startTime;
        let elapsedTime = 0;
        let timerInterval;
        let isInspecting = false;
        let isTiming = false;
        let inspectionTimeLeft = 15;
        let inspectionCountdownInterval;
        let scramble = '';
        let solves = []; // Array to store solve objects: [{ id: uuid, time: ms, penalty: null|'+2'|'DNF', timestamp: date, scramble: string }]
        let spaceDownTime = 0; // Initialize here, directly in the module scope.
        
        // Declare DOM element variables globally, assign them in window.onload
        let timerDisplay;
        let scrambleTextDisplay; // Renamed
        let cube3DContainer;     // New
        let scramble3DViewer;    // New (now twisty-player)
        let startStopBtn;
        let resetBtn;
        let scrambleBtn;
        let settingsBtn;
        let solveHistoryList;
        let bestTimeDisplay;
        let ao5Display;
        let ao12Display;
        let solveCountDisplay;
        let noSolvesMessage;
        let inspectionToggle;
        let soundEffectsToggle;
        let cubeTypeSelect;
        let themeSelect;
        let cubeViewToggle; // New
        let settingsUsernameInput;
        let saveUsernameBtn;
        let usernameUpdateMessage;
        let aiInsightModal;
        let closeAiInsightModalBtn;
        let aiInsightContentDisplay;
        let insightMessageElement;
        let insightSpinner;
        let optimalSolutionDisplay; // New
        let optimalSolutionText;    // New
        let personalizedTipDisplay; // New
        let personalizedTipText;    // New
        // New variables for toolbar buttons
        let playPreviewBtn;
        let pausePreviewBtn;
        let restartPreviewBtn;
        // Voice command button
        let voiceCommandBtn; // New
        let isListeningForVoice = false; // New state for voice recognition

        // Web Speech API
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const SpeechSynthesis = window.SpeechSynthesisUtterance;
        const recognition = SpeechRecognition ? new SpeechRecognition() : null;
        const synth = window.speechSynthesis;

        if (recognition) {
            recognition.continuous = false; // Stop after first utterance
            recognition.interimResults = false; // Only return final results
            recognition.lang = 'en-US'; // Set language

            recognition.onstart = () => {
                console.log("[DEBUG] Voice recognition started.");
                isListeningForVoice = true;
                if (voiceCommandBtn) voiceCommandBtn.classList.add('active');
                speakAsJarvis("Listening, Sir.");
            };

            recognition.onresult = (event) => {
                const command = event.results[0][0].transcript; // Keep raw transcript for Gemini
                console.log(`[DEBUG] Raw voice command received: "${command}"`);
                processVoiceCommandWithGemini(command); // Send to Gemini for NLU
            };

            recognition.onend = () => {
                console.log("[DEBUG] Voice recognition ended.");
                isListeningForVoice = false;
                if (voiceCommandBtn) voiceCommandBtn.classList.remove('active');
            };

            recognition.onerror = (event) => {
                console.error(`[ERROR] Voice recognition error: ${event.error}`);
                isListeningForVoice = false;
                if (voiceCommandBtn) voiceCommandBtn.classList.remove('active');
                // Only speak error if it's not a common "no-speech" or "not-allowed"
                if (event.error !== 'no-speech' && event.error !== 'not-allowed') {
                    speakAsJarvis(`Pardon me, Sir. An error occurred with voice input: ${event.error}.`);
                }
            };
        } else {
            console.warn("[WARN] Web Speech API not supported in this browser.");
        }

        /**
         * Jarvis speaks.
         * @param {string} text - The text for Jarvis to speak.
         */
        function speakAsJarvis(text) {
            if (enableSoundEffects && synth && SpeechSynthesis) {
                const utterance = new SpeechSynthesis(text);
                utterance.voice = synth.getVoices().find(voice => voice.name.includes('Google US English')); // Try to find a good voice
                utterance.pitch = 1;
                utterance.rate = 1;
                synth.speak(utterance);
                console.log(`[DEBUG] Jarvis speaking: "${text}"`);
            } else {
                console.log(`[DEBUG] Jarvis would speak (sounds disabled or API not supported): "${text}"`);
            }
        }

        /**
         * Sends the raw voice transcript to Gemini NLU Cloud Function for interpretation.
         * @param {string} rawTranscript - The raw, unparsed transcript from speech recognition.
         */
        async function processVoiceCommandWithGemini(rawTranscript) {
            console.log(`[DEBUG] Sending raw transcript to Gemini NLU: "${rawTranscript}"`);
            
            if (!geminiNluFunctionUrl || geminiNluFunctionUrl === "YOUR_GEMINI_NLU_VERCEL_FUNCTION_URL") {
                speakAsJarvis("Sir, the Natural Language Understanding module is not configured. Please provide its deployment URL.");
                console.error("[ERROR] Gemini NLU Cloud Function URL is not configured.");
                return;
            }

            speakAsJarvis("Processing command, Sir.");

            try {
                const response = await fetch(geminiNluFunctionUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ transcript: rawTranscript })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`NLU Cloud Function error: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                console.log("[DEBUG] Gemini NLU response:", result);

                const canonicalCommand = result.canonicalCommand;
                if (canonicalCommand) {
                    handleCanonicalCommand(canonicalCommand);
                } else {
                    speakAsJarvis("Pardon me, Sir. I could not determine a clear command from your request.");
                    console.warn("[WARN] Gemini NLU did not return a canonical command.");
                }

            } catch (e) {
                speakAsJarvis(`Sir, I encountered an error communicating with the Natural Language Understanding module: ${e.message}`);
                console.error("[ERROR] Error calling Gemini NLU Cloud Function:", e);
            }
        }

        /**
         * Handles the canonical command received from Gemini NLU.
         * @param {string} canonicalCommand - The simplified, standardized command (e.g., "start_timer").
         */
        function handleCanonicalCommand(canonicalCommand) {
            console.log(`[DEBUG] Handling canonical command: "${canonicalCommand}"`);

            switch (canonicalCommand) {
                case 'start_timer':
                    if (!isTiming) {
                        speakAsJarvis("Initiating timer sequence, Sir.");
                        toggleTimer();
                    } else {
                        speakAsJarvis("The timer is already in progress, Sir.");
                    }
                    break;
                case 'stop_timer':
                    if (isTiming) {
                        speakAsJarvis("Timer halted, Sir.");
                        toggleTimer(); // This will stop the timer and add solve
                    } else {
                        speakAsJarvis("The timer is not currently running, Sir.");
                    }
                    break;
                case 'new_scramble':
                    speakAsJarvis("Generating new scramble, Sir.");
                    scramble = generateScramble();
                    resetTimer();
                    break;
                case 'reset_timer':
                    speakAsJarvis("Timer reset, Sir.");
                    resetTimer();
                    break;
                case 'open_settings':
                    speakAsJarvis("Opening settings, Sir.");
                    if (settingsBtn) settingsBtn.click();
                    break;
                case 'close_settings':
                    speakAsJarvis("Closing settings, Sir.");
                    if (closeSettingsModalBtn) closeSettingsModalBtn.click();
                    break;
                case 'get_insight':
                    if (solves.length > 0) {
                        speakAsJarvis("Accessing neural network for solve analysis, Sir.");
                        getSolveInsight(solves[solves.length - 1].id); // Get insight for the last solve
                    } else {
                        speakAsJarvis("There are no solves recorded to analyze, Sir.");
                    }
                    break;
                case 'unknown':
                default:
                    speakAsJarvis("Pardon me, Sir. I did not fully comprehend your instruction. Please try again.");
                    break;
            }
        }

        // Sound effects
        // Initialize Tone.js synths. These are global to avoid re-creating them on every play.
        const startSound = new Tone.Synth({
            oscillator: { type: "triangle" },
            envelope: {
                attack: 0.01,
                decay: 0.1,
                sustain: 0.1,
                release: 0.5,
            }
        }).toDestination();
        console.log("[DEBUG] Tone.js startSound initialized.");

        const stopSound = new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 8,
            envelope: {
                attack: 0.001,
                decay: 0.4,
                sustain: 0.01,
                release: 0.6,
            }
        }).toDestination();
        console.log("[DEBUG] Tone.js stopSound initialized.");

        const inspectionBeep = new Tone.Synth({
            oscillator: { type: "square" },
            envelope: {
                attack: 0.005,
                decay: 0.05,
                sustain: 0.0,
                release: 0.05,
            }
        }).toDestination();
        console.log("[DEBUG] Tone.js inspectionBeep initialized.");

        // New sound for "Go!"
        const goSound = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.02,
                decay: 0.2,
                sustain: 0.1,
                release: 0.3,
            }
        }).toDestination();
        console.log("[DEBUG] Tone.js goSound initialized.");

        // Settings variables
        let enableInspection = true;
        let enableSoundEffects = true;
        let cubeType = '3x3';
        let currentTheme = 'dark'; // Default theme
        let show3DCubeView = false; // New: Default to text scramble view
        console.log("[DEBUG] Initial settings variables set.");

        // --- Local Storage Functions for Guest Mode ---
        const LOCAL_STORAGE_PREFIX = `${appId}_guest_`;

        /**
         * Loads solves from local storage.
         */
        function loadLocalSolves() {
            console.log("[DEBUG] Loading solves from local storage.");
            try {
                const storedSolves = localStorage.getItem(`${LOCAL_STORAGE_PREFIX}solves`);
                solves = storedSolves ? JSON.parse(storedSolves) : [];
                // Ensure timestamps are Date objects if needed later, or numbers for sorting
                solves.forEach(solve => {
                    if (typeof solve.timestamp === 'string') {
                        solve.timestamp = new Date(solve.timestamp).getTime();
                    }
                });
                console.log(`[DEBUG] Loaded ${solves.length} solves from local storage.`);
            } catch (e) {
                console.error("[ERROR] Error loading solves from local storage:", e);
                solves = [];
            }
        }

        /**
         * Saves solves to local storage.
         */
        function saveLocalSolves() {
            console.log("[DEBUG] Saving solves to local storage.");
            try {
                localStorage.setItem(`${LOCAL_STORAGE_PREFIX}solves`, JSON.stringify(solves));
                console.log("[DEBUG] Solves saved to local storage.");
            } catch (e) {
                console.error("[ERROR] Error saving solves to local storage:", e);
            }
        }

        /**
         * Loads user settings from local storage.
         */
        function loadLocalUserSettings() {
            console.log("[DEBUG] Loading user settings from local storage.");
            try {
                const storedSettings = localStorage.getItem(`${LOCAL_STORAGE_PREFIX}settings`);
                if (storedSettings) {
                    const settings = JSON.parse(storedSettings);
                    enableInspection = settings.enableInspection !== undefined ? settings.enableInspection : true;
                    enableSoundEffects = settings.soundEffects !== undefined ? settings.soundEffects : true;
                    cubeType = settings.cubeType || '3x3';
                    currentTheme = settings.theme || 'dark';
                    show3DCubeView = settings.show3DCubeView !== undefined ? settings.show3DCubeView : false;
                    console.log("[DEBUG] User settings loaded from local storage:", settings);
                } else {
                    console.log("[DEBUG] No user settings found in local storage, using defaults.");
                    saveLocalUserSettings(); // Save defaults for next time
                }
            } catch (e) {
                console.error("[ERROR] Error loading settings from local storage:", e);
            }
            applySettingsToUI();
        }

        /**
         * Saves current user settings to local storage.
         */
        function saveLocalUserSettings() {
            console.log("[DEBUG] Saving user settings to local storage.");
            try {
                const settingsToSave = {
                    enableInspection: enableInspection,
                    enableSoundEffects: enableSoundEffects,
                    cubeType: cubeType,
                    theme: currentTheme,
                    show3DCubeView: show3DCubeView,
                    lastUpdated: Date.now()
                };
                localStorage.setItem(`${LOCAL_STORAGE_PREFIX}settings`, JSON.stringify(settingsToSave));
                console.log("[DEBUG] User settings saved to local storage.");
            } catch (e) {
                console.error("[ERROR] Error saving settings to local storage:", e);
            }
        }

        /**
         * Loads username from local storage.
         */
        function loadLocalUsername() {
            console.log("[DEBUG] Loading username from local storage.");
            return localStorage.getItem(`${LOCAL_STORAGE_PREFIX}username`) || 'Guest';
        }

        /**
         * Saves username to local storage.
         */
        function saveLocalUsername(username) {
            console.log("[DEBUG] Saving username to local storage.");
            localStorage.setItem(`${LOCAL_STORAGE_PREFIX}username`, username);
        }

        // --- Utility Functions ---

        /**
         * Formats milliseconds into M:SS.mmm string.
         * @param {number} ms - Milliseconds to format.
         * @returns {string} Formatted time string.
         */
        function formatTime(ms) {
            if (ms === null || isNaN(ms)) {
                return '--:--.--';
            }
            const minutes = Math.floor(ms / 60000);
            const seconds = Math.floor((ms % 60000) / 1000);
            const milliseconds = Math.floor(ms % 1000);
            const formatted = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(milliseconds).padStart(3, '0')}`;
            return formatted;
        }

        /**
         * Generates a scramble based on the selected cube type.
         * @returns {string} A new scramble string.
         */
        function generateScramble() {
            console.log("[DEBUG] Entering generateScramble.");
            const moves3x3 = ['R', 'L', 'U', 'D', 'F', 'B'];
            const moves2x2 = ['R', 'U', 'F'];
            const moves4x4 = ['R', 'L', 'U', 'D', 'F', 'B', 'Rw', 'Uw', 'Fw']; // Simplified for demo
            const movesPyraminx = ['R', 'L', 'U', 'B']; // Main moves
            const movesPyraminxTips = ['r', 'l', 'u', 'b']; // Tips moves
            const suffixes = ['', "'", '2']; // For 3x3, 2x2, 4x4
            const suffixesPyraminx = ['', "'"]; // For Pyraminx

            let scrambleMoves = [];
            let length = 0;
            let twistyPlayerPuzzleType = '3x3x3'; // Default for twisty-player

            const getRandomMove = (movesArray, suffixArray) => {
                const move = movesArray[Math.floor(Math.random() * movesArray.length)];
                const suffix = suffixArray[Math.floor(Math.random() * suffixArray.length)];
                return move + suffix;
            };

            switch (cubeType) {
                case '2x2':
                    length = 9 + Math.floor(Math.random() * 3); // 9-11 moves
                    twistyPlayerPuzzleType = '2x2x2';
                    for (let i = 0; i < length; i++) {
                        scrambleMoves.push(getRandomMove(moves2x2, suffixes));
                    }
                    break;
                case '3x3':
                    length = 20 + Math.floor(Math.random() * 2); // 20-21 moves
                    twistyPlayerPuzzleType = '3x3x3';
                    for (let i = 0; i < length; i++) {
                        scrambleMoves.push(getRandomMove(moves3x3, suffixes));
                    }
                    break;
                case '4x4':
                    length = 40 + Math.floor(Math.random() * 6); // 40-45 moves
                    twistyPlayerPuzzleType = '4x4x4';
                    // This is a very simplified 4x4 scramble. Real 4x4 scrambles are more complex.
                    for (let i = 0; i < length; i++) {
                        scrambleMoves.push(getRandomMove(moves4x4, suffixes));
                    }
                    break;
                case 'pyraminx':
                    length = 8 + Math.floor(Math.random() * 3); // 8-10 moves for main
                    twistyPlayerPuzzleType = 'pyraminx'; // twisty-player supports 'pyraminx' puzzle type
                    for (let i = 0; i < length; i++) {
                        scrambleMoves.push(getRandomMove(movesPyraminx, suffixesPyraminx));
                    }
                    // Add tip moves (usually 0-4 tip moves)
                    for (let i = 0; i < Math.floor(Math.random() * 5); i++) {
                        scrambleMoves.push(getRandomMove(movesPyraminxTips, suffixesPyraminx));
                    }
                    break;
                default:
                    // Fallback to 3x3 if something unexpected
                    length = 20;
                    twistyPlayerPuzzleType = '3x3x3';
                    for (let i = 0; i < length; i++) {
                        scrambleMoves.push(getRandomMove(moves3x3, suffixes));
                    }
            }
            const generated = scrambleMoves.join(' ');
            console.log(`[DEBUG] generateScramble: Generated for ${cubeType}: ${generated}`);

            // Update both displays regardless of current view setting
            if (scrambleTextDisplay) { // Defensive check
                scrambleTextDisplay.textContent = generated;
            }
            if (scramble3DViewer) { // Ensure the element is available
                // Always set puzzle type explicitly.
                scramble3DViewer.puzzle = twistyPlayerPuzzleType; 
                // Set algorithm after a very short delay if puzzle type is pyraminx
                // to give the component a moment to fully reconfigure its parser.
                // This specifically targets the "Invalid suffix" error that seems specific to Pyraminx
                // due to timing sensitivities with twisty-player's internal parsing.
                if (cubeType === 'pyraminx') {
                    // Clear alg first to ensure a fresh parse.
                    scramble3DViewer.alg = ''; 
                    setTimeout(() => {
                        scramble3DViewer.alg = generated;
                        console.log(`[DEBUG] 3D Viewer (Pyraminx, delayed) updated with alg: ${generated}`);
                    }, 50); // A small delay (50ms) to ensure internal parser is ready.
                } else {
                    scramble3DViewer.alg = generated;
                    console.log(`[DEBUG] 3D Viewer updated with alg: ${generated} and puzzle: ${twistyPlayerPuzzleType}`);
                }
            } else {
                console.warn("[WARN] scramble3DViewer is not yet available during generateScramble. This is expected on initial load if 3D view is off.");
            }
            return generated;
        }

        /**
         * Calculates the average of the last N solves, dropping the best and worst times.
         * @param {Array<Object>} solveList - Array of solve objects.
         * @param {number} n - Number of solves to consider (e.g., 5 for Ao5, 12 for Ao12).
         * @returns {string} Formatted average time or '--:--.--'.
         */
        function calculateAverage(solveList, n) {
            console.log(`[DEBUG] Entering calculateAverage for N=${n} with ${solveList.length} solves.`);
            if (solveList.length < n) {
                console.log(`[DEBUG] calculateAverage: Not enough solves (${solveList.length} < ${n}). Returning '--:--.--'.`);
                return '--:--.--';
            }

            // Get the last N solves
            const lastNSolves = solveList.slice(-n);
            console.log(`[DEBUG] calculateAverage: Last ${n} solves:`, lastNSolves.map(s => `${s.time}ms (penalty: ${s.penalty})`));

            // Filter out DNFs and apply +2 penalties for calculations
            let timesForAvg = [];
            let hasDNF = false;
            lastNSolves.forEach(solve => {
                if (solve.penalty === 'DNF') {
                    hasDNF = true;
                    console.log("[DEBUG] calculateAverage: DNF found.");
                } else if (solve.penalty === '+2') {
                    timesForAvg.push(solve.time + 2000);
                    console.log(`[DEBUG] calculateAverage: Added +2 penalty to ${solve.time}ms.`);
                } else {
                    timesForAvg.push(solve.time);
                }
            });

            // If there's a DNF, the average is DNF
            if (hasDNF) {
                console.log("[DEBUG] calculateAverage: Returning 'DNF' due to DNF in list.");
                return 'DNF';
            }

            // Sort times to drop best and worst
            timesForAvg.sort((a, b) => a - b);
            console.log("[DEBUG] calculateAverage: Times sorted:", timesForAvg);

            // Drop best and worst if timesForAvg.length allows (e.g., for Ao5, drop 1st and last from 5)
            if (timesForAvg.length > 2) {
                timesForAvg = timesForAvg.slice(1, -1);
                console.log("[DEBUG] calculateAverage: Dropped best/worst. Remaining times:", timesForAvg);
            } else {
                console.log("[DEBUG] calculateAverage: Not enough times to drop best/worst after filtering or N is too small.");
            }
            

            if (timesForAvg.length === 0) {
                console.log("[DEBUG] calculateAverage: No valid times for average. Returning '--:--.--'.");
                return '--:--.--';
            }

            const sum = timesForAvg.reduce((acc, time) => acc + time, 0);
            const avg = sum / timesForAvg.length;
            const formattedAvg = formatTime(avg);
            console.log(`[DEBUG] calculateAverage: Sum: ${sum}, Count: ${timesForAvg.length}, Avg: ${avg}ms, Formatted: ${formattedAvg}`);
            return formattedAvg;
        }

        /**
         * Renders the solve history list and updates statistics.
         */
        function renderSolveHistory() {
            console.log("[DEBUG] Entering renderSolveHistory.");
            // Ensure solveHistoryList is defined before accessing its properties
            if (!solveHistoryList) {
                console.warn("[WARN] renderSolveHistory called before solveHistoryList is initialized. Skipping render.");
                return; // Exit if DOM element is not ready
            }

            solveHistoryList.innerHTML = '';
            if (solves.length === 0) {
                if (noSolvesMessage) noSolvesMessage.style.display = 'block';
                if (bestTimeDisplay) bestTimeDisplay.textContent = '--:--.--';
                if (ao5Display) ao5Display.textContent = '--:--.--';
                if (ao12Display) ao12Display.textContent = '--:--.--';
                if (solveCountDisplay) solveCountDisplay.textContent = '0';
                console.log("[DEBUG] renderSolveHistory: No solves, displaying empty stats.");
                return;
            } else {
                if (noSolvesMessage) noSolvesMessage.style.display = 'none';
            }

            // Sort solves by timestamp (descending) for display
            const sortedSolves = [...solves].sort((a, b) => b.timestamp - a.timestamp);
            console.log(`[DEBUG] renderSolveHistory: Rendering ${sortedSolves.length} sorted solves.`);

            sortedSolves.forEach(solve => {
                const solveItem = document.createElement('div');
                solveItem.className = 'solve-history-item';
                solveItem.setAttribute('data-id', solve.id);

                let displayTime = solve.time;
                let penaltyText = '';
                if (solve.penalty === '+2') {
                    displayTime += 2000;
                    penaltyText = ' (+2)';
                } else if (solve.penalty === 'DNF') {
                    displayTime = 'DNF';
                    penaltyText = ' (DNF)';
                }

                solveItem.innerHTML = `
                    <div class="time">${displayTime === 'DNF' ? 'DNF' : formatTime(displayTime)}<span class="text-sm text-gray-400 ml-2">${penaltyText}</span></div>
                    <div class="penalty-buttons">
                        <button class="insight-button button-secondary" onclick="getSolveInsight('${solve.id}')">Get Insight âœ¨</button>
                        <button class="plus2 button-secondary" onclick="applyPenalty('${solve.id}', '+2')">+2</button>
                        <button class="button-secondary" onclick="applyPenalty('${solve.id}', 'DNF')">DNF</button>
                        <button class="clear-penalty button-secondary" onclick="applyPenalty('${solve.id}', null)">Clear</button>
                        <button class="delete button-secondary" onclick="deleteSolve('${solve.id}')">Delete</button>
                    </div>
                `;
                solveHistoryList.appendChild(solveItem);
                // console.log(`[DEBUG] renderSolveHistory: Appended solve item for ID: ${solve.id}`);
            });

            updateStatistics();
            console.log("[DEBUG] Exiting renderSolveHistory. Statistics updated.");
        }

        /**
         * Updates the best time, Ao5, Ao12, and solve count displays.
         */
        function updateStatistics() {
            console.log("[DEBUG] Entering updateStatistics.");
            // Ensure elements are defined
            if (!bestTimeDisplay || !ao5Display || !ao12Display || !solveCountDisplay) {
                 console.warn("[WARN] updateStatistics called before all display elements are initialized. Skipping update.");
                 return;
            }

            const validSolves = solves.filter(s => s.penalty !== 'DNF');
            let actualTimes = validSolves.map(s => s.time + (s.penalty === '+2' ? 2000 : 0));

            const best = actualTimes.length > 0 ? Math.min(...actualTimes) : null;
            bestTimeDisplay.textContent = formatTime(best);
            console.log(`[DEBUG] Statistics: Best Time: ${formatTime(best)}`);

            ao5Display.textContent = calculateAverage(solves, 5);
            console.log(`[DEBUG] Statistics: Ao5: ${ao5Display.textContent}`);
            ao12Display.textContent = calculateAverage(solves, 12);
            console.log(`[DEBUG] Statistics: Ao12: ${ao12Display.textContent}`);
            solveCountDisplay.textContent = solves.length;
            console.log(`[DEBUG] Statistics: Solve Count: ${solves.length}`);
            console.log("[DEBUG] Exiting updateStatistics.");
        }

        /**
         * Adds a new solve to the history.
         * Uses Firestore for authenticated users, Local Storage for guests.
         * @param {number} time - The solve time in milliseconds.
         */
        async function addSolve(time) {
            console.log(`[DEBUG] Entering addSolve with time: ${time}ms.`);
            const newSolve = {
                id: crypto.randomUUID(), // Always generate a local ID for consistency
                time: time,
                penalty: null,
                timestamp: Date.now(),
                scramble: scramble, // Store the scramble with the solve
            };

            if (isUserAuthenticated && db && userId) { // Authenticated user
                console.log("[DEBUG] addSolve: Authenticated and Firestore ready. Attempting to add to Firestore.");
                try {
                    const solvesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/solves`);
                    // Firestore will generate its own ID, so we remove the local 'id' for addDoc
                    const { id, ...solveDataToSave } = newSolve; 
                    const docRef = await addDoc(solvesCollectionRef, solveDataToSave);
                    console.log("[DEBUG] Document written to Firestore with ID: ", docRef.id);
                    // The onSnapshot listener will update the 'solves' array and re-render
                } catch (e) {
                    console.error("[ERROR] Error adding document to Firestore: ", e);
                    // Fallback to local array if Firestore fails, but won't persist across sessions
                    solves.push(newSolve); // Use the locally generated ID
                    saveLocalSolves(); // Save locally for current session
                    renderSolveHistory();
                    console.log("[DEBUG] addSolve: Firestore failed, added to local array (non-persistent).");
                }
            } else { // Guest user
                console.log("[DEBUG] addSolve: Guest user. Adding to local array and saving to local storage.");
                solves.push(newSolve);
                saveLocalSolves(); // Save to local storage for guest
                renderSolveHistory();
            }
            console.log("[DEBUG] Exiting addSolve.");

            // Automatically trigger AI insight after a solve
            // Check if AI Insight function URL is configured before calling
            // This is the correct constant to check, not a hardcoded string
            if (geminiInsightFunctionUrl) { 
                 speakAsJarvis("Your solve is complete, Sir. Analyzing your performance.");
                 // Use the latest solve (which is the newSolve just added)
                 getSolveInsight(newSolve.id); 
            } else {
                 console.warn("[WARN] Gemini Insight function URL not configured, skipping automatic insight generation.");
            }
        }

        /**
         * Determines the user's cubing level based on solve time for a 3x3 cube.
         * This is a simple heuristic and can be adjusted.
         * @param {number} solveTimeMs - The solve time in milliseconds.
         * @param {string} cubeType - The type of cube (e.g., '3x3').
         * @returns {string} The estimated level (e.g., "Beginner", "Intermediate", "Advanced", "Expert").
         */
        function getUserLevel(solveTimeMs, cubeType) {
            console.log(`[DEBUG] Determining user level for ${cubeType} solve time: ${solveTimeMs}ms`);
            if (cubeType === '3x3') {
                if (solveTimeMs > 120000) return "Beginner"; // Over 2 minutes (120,000 ms)
                if (solveTimeMs > 60000) return "Novice";   // 1-2 minutes (60,000 ms)
                if (solveTimeMs > 30000) return "Intermediate"; // 30-60 seconds (30,000 ms)
                if (solveTimeMs > 15000) return "Advanced";   // 15-30 seconds (15,000 ms)
                return "Expert"; // Under 15 seconds
            }
            // Add more cube types and their thresholds here if needed
            return "General Cubist"; // Default for other cube types or if not specified
        }

        /**
         * Fetches an AI-generated insight for a specific solve from the Cloud Function.
         * @param {string} solveId - The ID of the solve for which to generate an insight.
         */
        window.getSolveInsight = async function(solveId) {
            console.log(`[DEBUG] Requesting AI insight for solve ID: ${solveId}`);
            const solve = solves.find(s => s.id === solveId);

            if (!solve) {
                if (insightMessageElement) insightMessageElement.textContent = "Error: Solve not found.";
                if (insightSpinner) insightSpinner.style.display = 'none';
                if (aiInsightModal) aiInsightModal.classList.add('open');
                console.error(`[ERROR] Solve with ID ${solveId} not found.`);
                return;
            }

            // Display loading state and hide previous content
            if (insightMessageElement) insightMessageElement.textContent = "Generating insight...";
            if (insightSpinner) insightSpinner.style.display = 'block';
            if (optimalSolutionDisplay) optimalSolutionDisplay.style.display = 'none';
            if (personalizedTipDisplay) personalizedTipDisplay.style.display = 'none';
            if (aiInsightModal) {
                aiInsightModal.classList.add('open');
                aiInsightModal.focus(); // Focus the modal for accessibility
            }

            // Determine user level for personalized tip
            const userLevel = getUserLevel(solve.time, cubeType);

            // Prepare the data to send to the Cloud Function
            const requestData = {
                type: "get_insight", // Indicate the type of request
                scramble: solve.scramble,
                cubeType: cubeType,
                solveTimeMs: solve.time,
                penalty: solve.penalty,
                userLevel: userLevel
            };

            // Use the Cloud Function URL
            const apiUrl = geminiInsightFunctionUrl; // Corrected to use the variable directly

            // Now, this check truly verifies if the URL is set.
            if (!apiUrl || apiUrl === "YOUR_GEMINI_INSIGHT_VERCEL_FUNCTION_URL") { 
                if (insightMessageElement) insightMessageElement.textContent = "AI Insight Cloud Function URL not configured. Please ensure your Vercel function is deployed and the URL is correct.";
                if (insightSpinner) insightSpinner.style.display = 'none';
                console.error("[ERROR] Gemini Insight Cloud Function URL is not set or is default placeholder.");
                speakAsJarvis("Sir, the AI insight system is currently offline. Please configure the cloud function URL.");
                return;
            }

            try {
                console.log("[DEBUG] Making Cloud Function call for insight with data:", requestData);
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Cloud Function error: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                console.log("[DEBUG] Cloud Function raw response:", result);

                // Display insights
                if (result.insight && insightMessageElement) {
                    insightMessageElement.textContent = result.insight;
                    insightMessageElement.style.display = 'block';
                } else {
                    insightMessageElement.textContent = "General insight unavailable.";
                }

                if (result.optimalSolution && optimalSolutionText && optimalSolutionDisplay) {
                    optimalSolutionText.textContent = result.optimalSolution;
                    optimalSolutionDisplay.style.display = 'block';
                } else {
                    if (optimalSolutionDisplay) optimalSolutionDisplay.style.display = 'none';
                }

                if (result.personalizedTip && personalizedTipText && personalizedTipDisplay) {
                    personalizedTipText.textContent = result.personalizedTip;
                    personalizedTipDisplay.style.display = 'block';
                    speakAsJarvis(`Sir, my analysis suggests: ${result.personalizedTip}`);
                } else {
                    if (personalizedTipDisplay) personalizedTipDisplay.style.display = 'none';
                }
                
                console.log("[DEBUG] Cloud Function response received and displayed.");

            } catch (e) {
                if (insightMessageElement) insightMessageElement.textContent = `Failed to get insight: ${e.message}`;
                console.error("[ERROR] Error calling Cloud Function:", e);
                speakAsJarvis(`Sir, I encountered an error while generating insight: ${e.message}`);
            } finally {
                if (insightSpinner) insightSpinner.style.display = 'none'; // Hide spinner
                console.log("[DEBUG] AI Insight generation process completed.");
            }
        };

        /**
         * Applies or clears a penalty for a given solve.
         * Uses Firestore for authenticated users, Local Storage for guests.
         * @param {string} id - The ID of the solve to update.
         * @param {string|null} penaltyType - '+2', 'DNF', or null to clear.
         */
        window.applyPenalty = async function(id, penaltyType) {
            console.log(`[DEBUG] Entering applyPenalty for ID: ${id}, Penalty: ${penaltyType}`);
            if (isUserAuthenticated && db && userId) { // Authenticated user
                const solveRef = doc(db, `artifacts/${appId}/users/${userId}/solves`, id);
                try {
                    console.log(`[DEBUG] applyPenalty: Attempting to update doc in Firestore: ${solveRef.path}`);
                    await updateDoc(solveRef, { penalty: penaltyType });
                    console.log(`[DEBUG] Penalty ${penaltyType} applied to solve ${id} in Firestore.`);
                } catch (e) {
                    console.error("[ERROR] Error updating penalty in Firestore: ", e);
                    // Fallback to local update if Firestore fails
                    const solveIndex = solves.findIndex(s => s.id === id);
                    if (solveIndex !== -1) {
                        solves[solveIndex].penalty = penaltyType;
                        saveLocalSolves(); // Save locally for current session
                        renderSolveHistory(); // Re-render local changes
                        console.log("[DEBUG] applyPenalty: Firestore failed, applied locally (non-persistent).");
                    } else {
                        console.log("[DEBUG] applyPenalty: Solve not found in local array.");
                    }
                }
            } else { // Guest user
                console.log("[DEBUG] applyPenalty: Guest user. Applying penalty to local array and saving to local storage.");
                const solveIndex = solves.findIndex(s => s.id === id);
                if (solveIndex !== -1) {
                    solves[solveIndex].penalty = penaltyType;
                    saveLocalSolves(); // Save locally for guest
                    renderSolveHistory(); // Re-render local changes
                } else {
                    console.log("[DEBUG] applyPenalty: Solve not found in local array.");
                }
            }
            console.log("[DEBUG] Exiting applyPenalty.");
        };

        /**
         * Deletes a solve from the history.
         * Uses Firestore for authenticated users, Local Storage for guests.
         * @param {string} id - The ID of the solve to delete.
         */
        window.deleteSolve = async function(id) {
            console.log(`[DEBUG] Entering deleteSolve for ID: ${id}`);
            if (isUserAuthenticated && db && userId) { // Authenticated user
                const solveRef = doc(db, `artifacts/${appId}/users/${userId}/solves`, id);
                try {
                    console.log(`[DEBUG] deleteSolve: Attempting to delete doc from Firestore: ${solveRef.path}`);
                    await deleteDoc(solveRef);
                    console.log(`[DEBUG] Solve ${id} deleted from Firestore.`);
                } catch (e) {
                    console.error("[ERROR] Error deleting solve from Firestore: ", e);
                    // Fallback to local delete if Firestore fails
                    solves = solves.filter(s => s.id !== id);
                    saveLocalSolves(); // Save locally for current session
                    renderSolveHistory(); // Re-render local changes
                    console.log("[DEBUG] deleteSolve: Firestore failed, deleted locally (non-persistent).");
                }
            } else { // Guest user
                console.log("[DEBUG] deleteSolve: Guest user. Deleting from local array and saving to local storage.");
                solves = solves.filter(s => s.id !== id);
                saveLocalSolves(); // Save locally for guest
                renderSolveHistory();
            }
            console.log("[DEBUG] Exiting deleteSolve.");
        };

        /**
         * Sets up the real-time listener for user's solves from Firestore.
         * This function is only called for authenticated users.
         */
        function setupRealtimeSolvesListener() {
            console.log("[DEBUG] Entering setupRealtimeSolvesListener.");
            // Ensure DOM elements are initialized before proceeding
            if (!solveHistoryList) {
                console.warn("[WARN] setupRealtimeSolvesListener called before solveHistoryList is initialized. Skipping setup.");
                return;
            }

            if (isUserAuthenticated && db && userId) { // Only set up for authenticated users
                console.log("[DEBUG] setupRealtimeSolvesListener: Authenticated and Firestore ready. Setting up onSnapshot.");
                const solvesCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/solves`);
                // Note: orderBy is commented out due to potential index issues,
                // and data will be sorted in JavaScript.
                const q = query(solvesCollectionRef /*, orderBy('timestamp', 'desc')*/);

                // Clear previous local data if any from guest mode
                solves = []; 
                renderSolveHistory(); // Render empty list while Firestore data loads

                onSnapshot(q, (snapshot) => {
                    console.log("[DEBUG] onSnapshot callback triggered. Processing snapshot changes.");
                    solves = []; // Clear current solves to repopulate from snapshot
                    snapshot.forEach((doc) => {
                        solves.push({ id: doc.id, ...doc.data() });
                    });
                    console.log(`[DEBUG] Solves updated from Firestore. Total solves: ${solves.length}.`);
                    renderSolveHistory();
                }, (error) => {
                    console.error("[ERROR] Error listening to solves: ", error);
                    // Handle error, maybe display a message to the user
                    // Fallback to local if permissions error occurs on a previously working connection
                    if (error.code === 'permission-denied') {
                         console.warn("[WARN] Firestore permission denied for solves listener. Falling back to local storage for solves.");
                         isUserAuthenticated = false; // Treat as signed out if permissions fail
                         // Re-init with local storage for solves to ensure functionality
                         loadLocalSolves();
                         renderSolveHistory();
                    }
                });
            } else {
                console.log("[DEBUG] setupRealtimeSolvesListener: Not authenticated, Firestore listener not setup.");
                // For guests, local solves are handled by loadLocalSolves in initializeUserDataAndSettings
            }
            console.log("[DEBUG] Exiting setupRealtimeSolvesListener.");
        }

        /**
         * Loads user settings. Uses Firestore for authenticated users, Local Storage for guests.
         */
        async function loadUserSettings() {
            console.log("[DEBUG] Entering loadUserSettings.");
            // Ensure DOM elements are initialized before proceeding
            if (!inspectionToggle || !soundEffectsToggle || !cubeTypeSelect || !themeSelect || !cubeViewToggle) {
                 console.warn("[WARN] loadUserSettings called before settings UI elements are initialized. Skipping load.");
                 return;
            }

            if (isUserAuthenticated && db && userId) { // Authenticated user
                console.log("[DEBUG] loadUserSettings: Authenticated and Firestore ready. Attempting to load settings.");
                const userSettingsRef = doc(db, `artifacts/${appId}/users/${userId}/settings/preferences`);
                try {
                    const docSnap = await getDoc(userSettingsRef);
                    if (docSnap.exists()) {
                        const settings = docSnap.data();
                        enableInspection = settings.enableInspection !== undefined ? settings.enableInspection : true;
                        enableSoundEffects = settings.soundEffects !== undefined ? settings.soundEffects : true;
                        cubeType = settings.cubeType || '3x3';
                        currentTheme = settings.theme || 'dark';
                        show3DCubeView = settings.show3DCubeView !== undefined ? settings.show3DCubeView : false; // Load new setting
                        console.log("[DEBUG] User settings loaded from Firestore:", settings);
                    } else {
                        console.log("[DEBUG] No user settings found in Firestore, using defaults and saving.");
                        saveUserSettings(); // Save default settings to Firestore
                    }
                }
                catch (e) {
                    console.error("[ERROR] Error loading user settings from Firestore: ", e);
                    if (e.code === 'permission-denied') {
                         console.warn("[WARN] Firestore permission denied for settings. Falling back to local storage for settings.");
                         // Fallback to local if permissions fail
                         loadLocalUserSettings();
                    }
                }
            } else { // Guest user
                 console.log("[DEBUG] loadUserSettings: Guest user. Loading settings from local storage.");
                 loadLocalUserSettings(); // Load from local storage
            }
            applySettingsToUI();
            console.log("[DEBUG] Exiting loadUserSettings.");
        }

        /**
         * Saves current user settings. Uses Firestore for authenticated users, Local Storage for guests.
         */
        async function saveUserSettings() {
            console.log("[DEBUG] Entering saveUserSettings.");
            if (isUserAuthenticated && db && userId) { // Authenticated user
                console.log("[DEBUG] saveUserSettings: Authenticated and Firestore ready. Attempting to save settings.");
                const userSettingsRef = doc(db, `artifacts/${appId}/users/${userId}/settings/preferences`);
                const settingsToSave = {
                    enableInspection: enableInspection,
                    enableSoundEffects: enableSoundEffects,
                    cubeType: cubeType,
                    theme: currentTheme,
                    show3DCubeView: show3DCubeView, // Save new setting
                    lastUpdated: Date.now()
                };
                try {
                    console.log("[DEBUG] Attempting to set doc in Firestore:", settingsToSave);
                    await setDoc(userSettingsRef, settingsToSave, { merge: true });
                    console.log("[DEBUG] User settings saved to Firestore.");
                } catch (e) {
                    console.error("[ERROR] Error saving user settings to Firestore: ", e);
                    // Fallback to local save if Firestore fails
                    saveLocalUserSettings();
                    console.warn("[WARN] Firestore failed to save settings, saved to local storage (non-persistent).");
                }
            } else { // Guest user
                 console.log("[DEBUG] saveUserSettings: Guest user. Saving settings to local storage.");
                 saveLocalUserSettings(); // Save to local storage
            }
            console.log("[DEBUG] Exiting saveUserSettings.");
        }

        /**
         * Retrieves the hexadecimal color code for the primary background based on the current theme.
         * @param {string} theme - The name of the current theme ('dark', 'light', 'vibrant').
         * @returns {string} The hexadecimal color code.
         */
        function getThemeBackgroundColorHex(theme) {
            switch (theme) {
                case 'dark':
                    return '#0f172a';
                case 'light':
                    return '#f0f2f5';
                case 'vibrant':
                    return '#2d0b57';
                default:
                    return '#0f172a'; // Default to dark theme's primary background
            }
        }

        /**
         * Applies loaded/default settings to the UI elements.
         */
        function applySettingsToUI() {
            console.log("[DEBUG] Entering applySettingsToUI.");
            // Ensure UI elements are initialized before trying to apply settings to them
            if (!inspectionToggle || !soundEffectsToggle || !cubeTypeSelect || !themeSelect || !cubeViewToggle) {
                 console.warn("[WARN] applySettingsToUI called before settings UI elements are initialized. Skipping apply.");
                 return;
            }

            if (inspectionToggle) inspectionToggle.checked = enableInspection;
            if (soundEffectsToggle) soundEffectsToggle.checked = enableSoundEffects;
            if (cubeTypeSelect) cubeTypeSelect.value = cubeType;
            if (themeSelect) themeSelect.value = currentTheme;
            if (cubeViewToggle) cubeViewToggle.checked = show3DCubeView; // Apply new setting to UI

            document.body.className = `theme-${currentTheme}`; // Apply theme class

            // Toggle visibility of scramble displays
            if (show3DCubeView) {
                if (scrambleTextDisplay) scrambleTextDisplay.style.display = 'none';
                if (cube3DContainer) cube3DContainer.style.display = 'flex'; // Use flex for centering
                if (scramble3DViewer) {
                    // Set the 3D viewer background directly using the hex color for the chosen theme
                    scramble3DViewer.setAttribute('background', getThemeBackgroundColorHex(currentTheme));
                }
            } else {
                if (scrambleTextDisplay) scrambleTextDisplay.style.display = 'block';
                if (cube3DContainer) cube3DContainer.style.display = 'none';
            }

            // Ensure scramble is generated/updated for the correct display
            scramble = generateScramble();
            console.log("[DEBUG] UI settings applied and scramble regenerated.");
            console.log("[DEBUG] Exiting applySettingsToUI.");
        }

        /**
         * Updates the username in Firestore for authenticated users, or local storage for guests.
         */
        async function updateUsername() {
            console.log("[DEBUG] Entering updateUsername.");
            const newUsername = settingsUsernameInput.value.trim();
            if (!newUsername) {
                if (usernameUpdateMessage) {
                    usernameUpdateMessage.textContent = "Username cannot be empty.";
                    usernameUpdateMessage.style.color = "#ef4444"; // Red for error
                    usernameUpdateMessage.style.display = 'block';
                }
                console.warn("[WARN] New username is empty.");
                return;
            }

            if (isUserAuthenticated && db && userId) { // Authenticated user
                const userProfileRef = doc(db, `artifacts/${appId}/users/${userId}/profile/data`);
                try {
                    console.log(`[DEBUG] Attempting to update username in Firestore to: ${newUsername}`);
                    await updateDoc(userProfileRef, { username: newUsername });
                    if (usernameUpdateMessage) {
                        usernameUpdateMessage.textContent = "Username updated successfully!";
                        usernameUpdateMessage.style.color = "#22c55e"; // Green for success
                        usernameUpdateMessage.style.display = 'block';
                    }
                    console.log("[DEBUG] Username updated successfully in Firestore.");
                    
                    // Update the displayed username immediately
                    // MODIFIED: Direct assignment of username without "User:" prefix
                    const usernameDisplayElement = document.getElementById('usernameDisplay'); // Ensure this is defined
                    if (usernameDisplayElement) usernameDisplayElement.textContent = `${newUsername}`; 
                    console.log("[DEBUG] Displayed username refreshed after update.");

                    setTimeout(() => {
                        if (usernameUpdateMessage) usernameUpdateMessage.style.display = 'none';
                        console.log("[DEBUG] Username update message hidden.");
                    }, 3000); // Hide message after 3 seconds

                } catch (e) { 
                    console.error("[ERROR] Error updating username in Firestore: ", e);
                    if (usernameUpdateMessage) {
                        usernameUpdateMessage.textContent = `Failed to update username: ${e.message}`;
                        usernameUpdateMessage.style.color = "#ef4444"; // Red for error
                        usernameUpdateMessage.style.display = 'block';
                    }
                    // Fallback to local save if Firestore fails
                    saveLocalUsername(newUsername);
                    // MODIFIED: Direct assignment for fallback
                    const usernameDisplayElement = document.getElementById('usernameDisplay');
                    if (usernameDisplayElement) usernameDisplayElement.textContent = `${newUsername}`; 
                    console.warn("[WARN] Firestore failed to update username, saved to local storage (non-persistent).");
                }
            } else { // Guest user
                console.log("[DEBUG] updateUsername: Guest user. Updating username in local storage.");
                saveLocalUsername(newUsername);
                if (usernameUpdateMessage) {
                    usernameUpdateMessage.textContent = "Username updated locally (not saved online).";
                    usernameUpdateMessage.style.color = "#fbbf24"; // Amber for warning
                    usernameUpdateMessage.style.display = 'block';
                }
                // MODIFIED: Direct assignment for guest username
                const usernameDisplayElement = document.getElementById('usernameDisplay');
                if (usernameDisplayElement) usernameDisplayElement.textContent = `Guest: ${newUsername}`; 
                setTimeout(() => {
                    if (usernameUpdateMessage) usernameUpdateMessage.style.display = 'none';
                    console.log("[DEBUG] Username update message hidden.");
                }, 3000);
            }
            console.log("[DEBUG] Exiting updateUsername.");
        }

        // --- Timer Logic ---

        /**
         * Starts or stops the timer/inspection.
         */
        async function toggleTimer() {
            console.log("[DEBUG] Entering toggleTimer.");
            // Ensure audio context is running on user interaction
            if (enableSoundEffects && Tone.context.state !== 'running') {
                await Tone.start();
                console.log("AudioContext ensured to be running (Tone.start() called).");
            }

            if (isTiming) {
                console.log("[DEBUG] toggleTimer: Currently timing, stopping timer.");
                // Stop the timer
                clearInterval(timerInterval);
                isTiming = false;
                if (startStopBtn) startStopBtn.textContent = 'Start / Stop (Space)';
                if (timerDisplay) timerDisplay.classList.remove('ready');
                if (enableSoundEffects) {
                    console.log("[DEBUG] Playing stop sound.");
                    stopSound.triggerAttackRelease("C2", "8n");
                }
                addSolve(elapsedTime); // Add solve to history (will handle Firestore/Local Storage)
                scramble = generateScramble(); // Generate new scramble for next solve
                if (timerDisplay) timerDisplay.textContent = formatTime(0); // Reset display to 0 for next solve
                elapsedTime = 0; // Reset elapsedTime
                console.log("[DEBUG] New scramble generated and timer reset for next solve.");
            } else if (isInspecting) {
                console.log("[DEBUG] toggleTimer: Currently inspecting, starting timer early.");
                // User pressed spacebar again during inspection to start timing early
                clearInterval(inspectionCountdownInterval);
                isInspecting = false;
                isTiming = true;
                if (timerDisplay) {
                    timerDisplay.classList.remove('inspection');
                    timerDisplay.classList.remove('ready'); // Remove ready state if it was there
                    timerDisplay.textContent = formatTime(0);
                }
                if (startStopBtn) startStopBtn.textContent = 'Stop (Space)';
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 10); // Update every 10ms for millisecond precision
                if (enableSoundEffects) {
                    console.log("Playing Go! sound (inspection stopped early).");
                    goSound.triggerAttackRelease(["C4", "E4", "G4"], "8n"); // "Go!" sound
                }
            } else {
                console.log("[DEBUG] toggleTimer: Initial start. Checking inspection setting.");
                // Initial start: enter inspection or start timer immediately
                if (enableInspection) {
                    isInspecting = true;
                    inspectionTimeLeft = 15;
                    if (timerDisplay) {
                        timerDisplay.classList.add('inspection');
                        timerDisplay.textContent = `Inspection: ${inspectionTimeLeft}`;
                    }
                    if (startStopBtn) startStopBtn.textContent = 'Start (Space)'; // Change button text for inspection phase
                    console.log("[DEBUG] Starting 15s inspection countdown.");

                    // Start inspection countdown and beeps
                    inspectionCountdownInterval = setInterval(() => {
                        inspectionTimeLeft--;
                        console.log(`[DEBUG] Inspection countdown: ${inspectionTimeLeft}s remaining.`);
                        if (timerDisplay) timerDisplay.textContent = `Inspection: ${inspectionTimeLeft}`;
                        if (inspectionTimeLeft >= 0) {
                            if (enableSoundEffects) {
                                // Play beep at 10 seconds and from 5 seconds down to 1
                                if (inspectionTimeLeft === 10 || (inspectionTimeLeft <= 5 && inspectionTimeLeft > 0)) {
                                    console.log(`[DEBUG] Playing inspection beep for ${inspectionTimeLeft}s.`);
                                    inspectionBeep.triggerAttackRelease("C5", "16n");
                                } else if (inspectionTimeLeft === 0) {
                                    // At 0 seconds, play a distinct beep and the "Go!" sound
                                    console.log("[DEBUG] Playing final inspection beep and Go! sound (0s).");
                                    inspectionBeep.triggerAttackRelease("C5", "8n"); // Louder/longer beep for 0
                                    goSound.triggerAttackRelease(["C4", "E4", "G4"], "8n"); // "Go!" sound

                                    // AUTOSTART THE TIMER HERE
                                    clearInterval(inspectionCountdownInterval); // Stop inspection countdown
                                    isInspecting = false;
                                    isTiming = true;
                                    if (timerDisplay) timerDisplay.classList.remove('inspection', 'ready');
                                    if (timerDisplay) timerDisplay.textContent = formatTime(0);
                                    if (startStopBtn) startStopBtn.textContent = 'Stop (Space)';
                                    startTime = Date.now();
                                    timerInterval = setInterval(updateTimer, 10); // Start actual timer
                                    console.log("[DEBUG] Inspection ended. Auto-starting timer.");
                                }
                            }

                            if (inspectionTimeLeft <= 8) { // After 8 seconds, ready to start
                                if (timerDisplay) timerDisplay.classList.add('ready');
                            }
                        } else {
                            console.log("[DEBUG] Inspection time ran out. Forcing stop.");
                            clearInterval(inspectionCountdownInterval);
                            isTiming = false; // Ensure timer isn't running without user input
                            isInspecting = false;
                            if (timerDisplay) timerDisplay.classList.remove('inspection', 'ready');
                            if (timerDisplay) timerDisplay.textContent = formatTime(0);
                            scramble = generateScramble();
                            if (startStopBtn) startStopBtn.textContent = 'Start / Stop (Space)';
                            if (enableSoundEffects) {
                                console.log("Playing forced stop sound due to inspection timeout.");
                                stopSound.triggerAttackRelease("F2", "8n"); // A different sound for forced stop
                            }
                            addSolve(elapsedTime + 2000); // Adding +2 if it went past 0 without manual start
                        }
                    }, 1000);
                } else {
                    console.log("[DEBUG] No inspection enabled. Starting timer immediately.");
                    // No inspection, start timer immediately
                    isTiming = true;
                    if (timerDisplay) timerDisplay.classList.remove('inspection', 'ready');
                    if (timerDisplay) timerDisplay.textContent = formatTime(0);
                    if (startStopBtn) startStopBtn.textContent = 'Stop (Space)';
                    startTime = Date.now();
                    timerInterval = setInterval(updateTimer, 10);
                    if (enableSoundEffects) {
                        console.log("Playing initial start sound (no inspection).");
                        startSound.triggerAttackRelease("C4", "8n"); // Initial start sound
                    }
                }
            }
            console.log("[DEBUG] Exiting toggleTimer.");
        }


        /**
         * Updates the timer display during timing phase.
         */
        function updateTimer() {
            elapsedTime = Date.now() - startTime;
            if (timerDisplay) timerDisplay.textContent = formatTime(elapsedTime);
        }

        /**
         * Resets the timer and generates a new scramble.
         */
        function resetTimer() {
            clearInterval(timerInterval);
            clearInterval(inspectionCountdownInterval);
            isTiming = false;
            isInspecting = false;
            elapsedTime = 0;
            inspectionTimeLeft = 15;
            if (timerDisplay) {
                timerDisplay.textContent = formatTime(0);
                timerDisplay.classList.remove('inspection', 'ready');
            }
            if (startStopBtn) startStopBtn.textContent = 'Start / Stop (Space)';
            scramble = generateScramble(); // Updates both text and 3D
        }

        // --- Event Listeners ---

        /**
         * Sets up all event listeners for buttons and keyboard input.
         */
        function setupEventListeners() {
            console.log("[DEBUG] setupEventListeners: Assigning event listeners.");
            // Defensive checks for element existence before adding listeners
            if (startStopBtn) startStopBtn.addEventListener('click', toggleTimer); else console.error("[ERROR] startStopBtn not found!");
            if (resetBtn) resetBtn.addEventListener('click', resetTimer); else console.error("[ERROR] resetBtn not found!");
            if (scrambleBtn) scrambleBtn.addEventListener('click', () => {
                scramble = generateScramble();
                resetTimer();
            }); else console.error("[ERROR] scrambleBtn not found!");
            if (settingsBtn) settingsBtn.addEventListener('click', async () => { // Added async for Tone.start()
                // Ensure audio context is running on settings button click
                if (enableSoundEffects && Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log("AudioContext ensured to be running (Tone.start() called on settingsBtn click).");
                }

                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal) {
                    settingsModal.classList.add('open');
                    settingsModal.focus();
                }
                // Pre-fill username input based on current user type
                if (isUserAuthenticated && auth && auth.currentUser && db && userId) {
                    const userProfileRef = doc(db, `artifacts/${appId}/users/${userId}/profile/data`);
                    getDoc(userProfileRef).then(docSnap => {
                        if (docSnap.exists() && docSnap.data().username && settingsUsernameInput) {
                            settingsUsernameInput.value = docSnap.data().username;
                        } else if (settingsUsernameInput) {
                            settingsUsernameInput.value = ''; // Clear if no username found
                        }
                    }).catch(e => {
                        console.error("Error loading username for settings:", e);
                        if (settingsUsernameInput) settingsUsernameInput.value = '';
                    });
                } else if (settingsUsernameInput) {
                    settingsUsernameInput.value = loadLocalUsername(); // Load from local storage for guests
                }

                if (usernameUpdateMessage) usernameUpdateMessage.style.display = 'none';
                applySettingsToUI(); // Apply settings to ensure all toggles/selects reflect current values
            }); else console.error("[ERROR] settingsBtn not found!");

            const closeSettingsModalBtn = document.getElementById('closeSettingsModal');
            if (closeSettingsModalBtn) closeSettingsModalBtn.addEventListener('click', () => {
                const settingsModal = document.getElementById('settingsModal');
                if (settingsModal) settingsModal.classList.remove('open');
                console.log("[DEBUG] Settings modal closed by button.");
                saveUserSettings(); // Save settings when modal is closed
            }); else console.error("[ERROR] closeSettingsModal not found!");

            const closeAuthModalBtn = document.getElementById('closeAuthModal');
            if (closeAuthModalBtn) closeAuthModalBtn.addEventListener('click', () => {
                const authModal = document.getElementById('authModal');
                if (authModal) authModal.classList.remove('open');
                clearAuthError();
                console.log("[DEBUG] Auth modal closed by button.");
            }); else console.error("[ERROR] closeAuthModal not found!");

            if (closeAiInsightModalBtn) closeAiInsightModalBtn.addEventListener('click', () => {
                if (aiInsightModal) aiInsightModal.classList.remove('open');
                console.log("[DEBUG] AI Insight modal closed by button.");
            }); else console.error("[ERROR] closeAiInsightModalBtn not found!");


            if (inspectionToggle) inspectionToggle.addEventListener('change', (e) => {
                enableInspection = e.target.checked;
                saveUserSettings();
            }); else console.error("[ERROR] inspectionToggle not found!");

            if (soundEffectsToggle) soundEffectsToggle.addEventListener('change', (e) => {
                enableSoundEffects = e.target.checked;
                saveUserSettings();
            }); else console.error("[ERROR] soundEffectsToggle not found!");

            if (cubeTypeSelect) cubeTypeSelect.addEventListener('change', (e) => {
                cubeType = e.target.value;
                saveUserSettings();
                scramble = generateScramble();
                resetTimer();
            }); else console.error("[ERROR] cubeTypeSelect not found!");

            if (themeSelect) themeSelect.addEventListener('change', (e) => {
                currentTheme = e.target.value;
                document.body.className = `theme-${currentTheme}`;
                saveUserSettings();
            }); else console.error("[ERROR] themeSelect not found!");

            if (cubeViewToggle) cubeViewToggle.addEventListener('change', (e) => {
                show3DCubeView = e.target.checked;
                applySettingsToUI();
                saveUserSettings();
            }); else console.error("[ERROR] cubeViewToggle not found!");

            if (saveUsernameBtn) saveUsernameBtn.addEventListener('click', updateUsername); else console.error("[ERROR] saveUsernameBtn not found!");

            // New: Event listeners for custom preview toolbar
            if (playPreviewBtn) playPreviewBtn.addEventListener('click', () => {
                if (scramble3DViewer) scramble3DViewer.play();
                console.log("[DEBUG] Play preview button clicked.");
            }); else console.error("[ERROR] playPreviewBtn not found!");

            if (pausePreviewBtn) pausePreviewBtn.addEventListener('click', () => {
                if (scramble3DViewer) scramble3DViewer.pause();
                console.log("[DEBUG] Pause preview button clicked.");
            }); else console.error("[ERROR] pausePreviewBtn not found!");

            if (restartPreviewBtn) restartPreviewBtn.addEventListener('click', () => {
                if (scramble3DViewer && scramble) {
                    // Jump to the start of the animation (effectively rewinds)
                    scramble3DViewer.jumpToStart();
                    // Play from the beginning
                    scramble3DViewer.play(); 
                    console.log("[DEBUG] Restart preview button clicked. Cube animation restarted from beginning.");
                }
            }); else console.error("[ERROR] restartPreviewBtn not found!");

            // Voice Command Button Listener
            if (voiceCommandBtn && recognition) { // Only add if both exist
                voiceCommandBtn.addEventListener('click', () => {
                    if (isListeningForVoice) {
                        recognition.stop();
                        speakAsJarvis("Voice input suspended.");
                    } else {
                        recognition.start();
                    }
                });
            } else if (voiceCommandBtn) {
                 // Hide if SpeechRecognition API is not supported
                 voiceCommandBtn.style.display = 'none';
                 console.warn("[WARN] Voice command button hidden as Web Speech API is not supported.");
            }


            document.addEventListener('keydown', (e) => {
                if (e.code === 'Escape') {
                    const settingsModal = document.getElementById('settingsModal');
                    if (settingsModal && settingsModal.classList.contains('open')) {
                        settingsModal.classList.remove('open');
                        saveUserSettings();
                        console.log("[DEBUG] Settings modal closed by Escape key.");
                    }
                    const authModal = document.getElementById('authModal');
                    if (authModal && authModal.classList.contains('open')) {
                        authModal.classList.remove('open');
                        clearAuthError();
                        console.log("[DEBUG] Auth modal closed by Escape key.");
                    }
                    if (aiInsightModal && aiInsightModal.classList.contains('open')) {
                        aiInsightModal.classList.remove('open');
                        console.log("[DEBUG] AI Insight modal closed by Escape key.");
                    }
                }

                if (e.code === 'Space') {
                    e.preventDefault();
                    // Ensure audio context is started on Spacebar press as well
                    if (enableSoundEffects && Tone.context.state !== 'running') {
                         Tone.start(); 
                         console.log("AudioContext ensured to be running (Tone.start() called on Spacebar keydown).");
                    }
                    if (e.repeat) return;
                    spaceDownTime = Date.now();
                    if (timerDisplay) timerDisplay.classList.add('ready');
                }
            });

            document.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    const spaceUpTime = Date.now();
                    const holdDuration = spaceUpTime - spaceDownTime;
                    if (timerDisplay) timerDisplay.classList.remove('ready');

                    if (holdDuration < 500 && !isTiming && !isInspecting) {
                        toggleTimer();
                    } else if (isInspecting && holdDuration >= 500) {
                        toggleTimer();
                    } else if (isTiming) {
                        toggleTimer();
                    }
                    spaceDownTime = 0;
                }
            });

            // --- Authentication Event Listeners ---
            const authModal = document.getElementById('authModal');
            const authModalTitle = document.getElementById('authModalTitle');
            const emailInput = document.getElementById('email');
            const usernameInputField = document.getElementById('usernameInput');
            const usernameFieldGroup = document.getElementById('usernameFieldGroup');
            const passwordInput = document.getElementById('password');
            const authError = document.getElementById('authError');
            const emailAuthBtn = document.getElementById('emailAuthBtn');
            const googleSignInBtn = document.getElementById('googleSignInBtn');
            const signInBtn = document.getElementById('signInBtn');
            const signUpBtn = document.getElementById('signUpBtn');
            const signOutBtn = document.getElementById('signOutBtn');

            function showAuthError(message) {
                if (authError) {
                    authError.textContent = message;
                    authError.style.display = 'block';
                }
            }

            function clearAuthError() {
                if (authError) {
                    authError.textContent = '';
                    authError.style.display = 'none';
                }
            }

            if (signInBtn) signInBtn.addEventListener('click', async () => { // Added async for Tone.start()
                // Ensure audio context is running on auth button click
                if (enableSoundEffects && Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log("AudioContext ensured to be running (Tone.start() called on signInBtn click).");
                }

                if (authModal) {
                    authModal.classList.add('open');
                    authModal.focus();
                }
                if (authModalTitle) authModalTitle.textContent = 'Sign In';
                if (emailAuthBtn) {
                    emailAuthBtn.textContent = 'Sign In';
                    emailAuthBtn.onclick = handleSignIn;
                }
                if (emailInput) emailInput.value = '';
                if (passwordInput) passwordInput.value = '';
                if(usernameFieldGroup) usernameFieldGroup.style.display = 'none';
                clearAuthError();
            }); else console.error("[ERROR] signInBtn not found!");

            if (signUpBtn) signUpBtn.addEventListener('click', async () => { // Added async for Tone.start()
                // Ensure audio context is running on auth button click
                if (enableSoundEffects && Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log("AudioContext ensured to be running (Tone.start() called on signUpBtn click).");
                }

                if (authModal) {
                    authModal.classList.add('open');
                    authModal.focus();
                }
                if (authModalTitle) authModalTitle.textContent = 'Sign Up';
                if (emailAuthBtn) {
                    emailAuthBtn.textContent = 'Sign Up';
                    emailAuthBtn.onclick = handleSignUp;
                }
                if (emailInput) emailInput.value = '';
                if (passwordInput) passwordInput.value = '';
                if(usernameInputField) usernameInputField.value = '';
                if(usernameFieldGroup) usernameFieldGroup.style.display = 'block';
                clearAuthError();
            }); else console.error("[ERROR] signUpBtn not found!");

            if (signOutBtn) signOutBtn.addEventListener('click', async () => { // Added async for Tone.start()
                // Ensure audio context is running on auth button click
                if (enableSoundEffects && Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log("AudioContext ensured to be running (Tone.start() called on signOutBtn click).");
                }

                if (auth) { // Only attempt sign out if auth object is initialized
                    try {
                        await signOut(auth);
                        // onAuthStateChanged will handle UI and data loading for the now-guest user.
                        console.log("User signed out successfully.");
                    } catch (error) {
                        console.error("Error signing out:", error);
                    }
                }
            }); else console.error("[ERROR] signOutBtn not found!");

            if (emailAuthBtn) emailAuthBtn.addEventListener('click', handleSignIn); // Direct assignment, not dynamic
            if (googleSignInBtn) googleSignInBtn.addEventListener('click', async () => {
                // Ensure audio context is running on Google Sign-In button click
                if (enableSoundEffects && Tone.context.state !== 'running') {
                    await Tone.start();
                    console.log("AudioContext ensured to be running (Tone.start() called on googleSignInBtn click).");
                }

                // Defensive check for auth before using it
                if (!auth) {
                    console.warn("[WARN] Google Sign-In: Firebase Auth not initialized.");
                    showAuthError("Authentication service not ready. Please try again.");
                    return;
                }
                const provider = new GoogleAuthProvider();
                clearAuthError();
                try {
                    const userCredential = await signInWithPopup(auth, provider);
                    const user = userCredential.user;
                    
                    if (db) { // Ensure db is initialized
                        const userProfileRef = doc(db, `artifacts/${appId}/users/${user.uid}/profile/data`);
                        const docSnap = await getDoc(userProfileRef);
                        if (!docSnap.exists() || !docSnap.data().username) {
                            const defaultUsername = user.displayName || (user.email ? user.email.split('@')[0] : 'GoogleUser');
                            await setDoc(userProfileRef, { username: defaultUsername }, { merge: true });
                            console.log(`[DEBUG] Default username saved for new Google user: ${defaultUsername}`);
                        }
                    }
                    if (authModal) authModal.classList.remove('open');
                    console.log("Signed in with Google.");
                } catch (error) {
                    showAuthError(error.message);
                    console.error("Google sign-in error:", error);
                }
            }); else console.error("[ERROR] googleSignInBtn not found!");

            // Helper functions for auth
            async function handleSignIn() {
                // Defensive check for auth before using it
                if (!auth) {
                    console.warn("[WARN] Email Sign-In: Firebase Auth not initialized.");
                    showAuthError("Authentication service not ready. Please try again.");
                    return;
                }
                const email = emailInput ? emailInput.value : '';
                const password = passwordInput ? passwordInput.value : '';
                clearAuthError();
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    if (authModal) authModal.classList.remove('open');
                    console.log("Signed in with email:", email);
                } catch (error) {
                    showAuthError(error.message);
                    console.error("Email sign-in error:", error);
                }
            }

            async function handleSignUp() {
                // Defensive check for auth before using it
                if (!auth) {
                    console.warn("[WARN] Email Sign-Up: Firebase Auth not initialized.");
                    showAuthError("Authentication service not ready. Please try again.");
                    return;
                }
                const email = emailInput ? emailInput.value : '';
                const username = usernameInputField ? usernameInputField.value.trim() : '';
                const password = passwordInput ? passwordInput.value : '';
                clearAuthError();

                if (!username) {
                    showAuthError("Please enter a username.");
                    return;
                }

                try {
                    const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                    const user = userCredential.user;
                    
                    if (db) { // Ensure db is initialized
                        const userProfileRef = doc(db, `artifacts/${appId}/users/${user.uid}/profile/data`);
                        await setDoc(userProfileRef, { username: username }, { merge: true });
                        console.log(`[DEBUG] Username saved for new email user: ${username}`);
                    }
                    if (authModal) authModal.classList.remove('open');
                    console.log("Signed up with email:", email, "Username:", username);
                } catch (error) {
                    showAuthError(error.message);
                    console.error("Email sign-up error:", error);
                }
            }
        }

        // --- Initialization on Window Load ---
        // This callback runs only after the entire DOM is loaded.
        window.onload = function() {
            console.log("[DEBUG] window.onload triggered. Initializing DOM elements and listeners.");
            // Assign DOM elements to variables after the document is loaded
            timerDisplay = document.getElementById('timerDisplay');
            scrambleTextDisplay = document.getElementById('scrambleTextDisplay');
            cube3DContainer = document.getElementById('cube3DContainer');
            scramble3DViewer = document.getElementById('scramble3DViewer');
            startStopBtn = document.getElementById('startStopBtn');
            resetBtn = document.getElementById('resetBtn');
            scrambleBtn = document.getElementById('scrambleBtn');
            settingsBtn = document.getElementById('settingsBtn');
            solveHistoryList = document.getElementById('solveHistoryList');
            bestTimeDisplay = document.getElementById('bestTime');
            ao5Display = document.getElementById('ao5');
            ao12Display = document.getElementById('ao12');
            solveCountDisplay = document.getElementById('solveCount');
            noSolvesMessage = document.getElementById('noSolvesMessage');
            inspectionToggle = document.getElementById('inspectionToggle');
            soundEffectsToggle = document.getElementById('soundEffectsToggle');
            cubeTypeSelect = document.getElementById('cubeTypeSelect');
            themeSelect = document.getElementById('themeSelect');
            cubeViewToggle = document.getElementById('cubeViewToggle');
            settingsUsernameInput = document.getElementById('settingsUsernameInput');
            saveUsernameBtn = document.getElementById('saveUsernameBtn');
            usernameUpdateMessage = document.getElementById('usernameUpdateMessage');
            aiInsightModal = document.getElementById('aiInsightModal');
            closeAiInsightModalBtn = document.getElementById('closeAiInsightModal');
            aiInsightContentDisplay = document.getElementById('aiInsightContent');
            insightMessageElement = document.getElementById('insightMessage');
            insightSpinner = aiInsightContentDisplay.querySelector('.spinner');
            optimalSolutionDisplay = document.getElementById('optimalSolutionDisplay');
            optimalSolutionText = document.getElementById('optimalSolutionText');
            personalizedTipDisplay = document.getElementById('personalizedTipDisplay');
            personalizedTipText = document.getElementById('personalizedTipText');
            playPreviewBtn = document.getElementById('playPreviewBtn');
            pausePreviewBtn = document.getElementById('pausePreviewBtn');
            restartPreviewBtn = document.getElementById('restartPreviewBtn');
            voiceCommandBtn = document.getElementById('voiceCommandBtn');


            // Set the flag to indicate DOM elements are ready
            domElementsReady = true; 

            // Initialize core features that need DOM elements ready
            scramble = generateScramble(); // Generates initial scramble and updates displays
            setupEventListeners(); // Attaches all event listeners to DOM elements

            // Attempt to initialize user data and settings now that DOM is ready.
            // This function itself checks if Firebase Auth is also ready.
            initializeUserDataAndSettings();

            console.log("[DEBUG] window.onload complete. Application should now be fully initialized.");
        };

    </script>
</body>
</html>
