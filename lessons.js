// Firebase imports - These are provided globally by the Canvas environment
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
console.log("[DEBUG] Firebase imports for lessons.js completed.");

// =====================================================================================================
// --- IMPORTANT: Firebase Configuration for Hosting (Duplicate for self-containment) ---
// These are duplicated from script.js to ensure lessons.js can function independently.
// =====================================================================================================
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id'; // Global app ID
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
    apiKey: "YOUR_FIREBASE_API_KEY", // Placeholder, will be replaced by Canvas
    authDomain: "YOUR_FIREBASE_AUTH_DOMAIN",
    projectId: "YOUR_FIREBASE_PROJECT_ID",
    storageBucket: "YOUR_FIREBASE_STORAGE_BUCKET",
    messagingSenderId: "YOUR_FIREBASE_MESSAGING_SENDER_ID",
    appId: "YOUR_FIREBASE_APP_ID",
    measurementId: "YOUR_FIREBASE_MEASUREMENT_ID"
};
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; // Global auth token

// Initialize Firebase App
let app;
let db;
let auth;
let userId = null;
let isAuthReady = false;
let isUserAuthenticated = false; // True if user is signed in (not guest)

// =====================================================================================================
// --- Global State Variables ---
// =====================================================================================================
let currentLesson = null; // Stores the full lesson object generated by AI
let currentLessonStepIndex = 0; // Current step being viewed
let completedSteps = new Set(); // Stores indices of completed steps for the current lesson
let lessonChatHistory = []; // For displaying messages in the chat UI
let backendChatHistory = []; // For sending conversational context to the AI (user/model roles)
let isAwaitingLessonGenerationConfirmation = false; // Flag to manage lesson generation flow
let currentCubeType = '3x3'; // Default, will be loaded from settings
let currentTheme = 'dark'; // Default, will be loaded from settings
let userLevel = 'beginner'; // Determined by best solve time, for AI context

// =====================================================================================================
// --- DOM Elements ---
// =====================================================================================================
let lessonHub, startNewLessonBtn, viewLessonHistoryBtn;
let lessonChatContainer, chatMessagesDisplay, lessonChatInput, sendLessonChatBtn, chatTypingIndicator;
let lessonDisplayArea, lessonTitleDisplay, lessonProgressBar, lessonStepTitleDisplay, lessonStepDescriptionDisplay,
    lessonVisualContainer, twistyPlayerLessonViewer, lessonExplanationDisplay, markStepCompleteBtn,
    prevLessonStepBtn, lessonStepCounter, nextLessonStepBtn, completeLessonBtn, lessonCompletionMessage;
let lessonPlayBtn, lessonPauseBtn, lessonResetViewBtn, lessonScrambleCubeBtn, lessonSolveCubeBtn;
let lessonHistorySection, lessonHistoryList, noLessonsMessage, historyLoadingSpinner;
let globalLoadingSpinner;

// =====================================================================================================
// --- Utility Functions ---
// =====================================================================================================

/**
 * Displays a toast notification to the user.
 * @param {string} message The message to display.
 * @param {string} type The type of toast ('success', 'error', 'info').
 */
function showToast(message, type = 'info') {
    const toastContainer = document.getElementById('toastContainer') || (() => {
        const div = document.createElement('div');
        div.id = 'toastContainer';
        div.className = 'toast-container';
        document.body.appendChild(div);
        return div;
    })();

    const toast = document.createElement('div');
    toast.className = `toast toast-${type} p-3 rounded-lg shadow-lg mb-3 text-white flex items-center`;
    toast.innerHTML = `
        <i class="fas ${type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-times-circle' : 'fa-info-circle'} mr-2"></i>
        <span>${message}</span>
    `;

    toastContainer.appendChild(toast);

    // Auto-remove after 3 seconds
    setTimeout(() => {
        toast.classList.add('fade-out');
        toast.addEventListener('transitionend', () => toast.remove());
    }, 3000);
}

/**
 * Speaks the given text using the Web Speech API.
 * @param {string} text The text to speak.
 */
function speakAsJarvis(text) {
    if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'en-US';
        // Try to find a suitable voice, e.g., a male voice
        const voices = speechSynthesis.getVoices();
        const jarvisVoice = voices.find(voice => voice.name.includes('Google US English') && voice.name.includes('Male')) ||
                            voices.find(voice => voice.lang === 'en-US' && voice.name.includes('Male')) ||
                            voices.find(voice => voice.lang === 'en-US'); // Fallback
        if (jarvisVoice) {
            utterance.voice = jarvisVoice;
        }
        speechSynthesis.speak(utterance);
        console.log(`[JARVIS] Speaking: "${text}"`);
    } else {
        console.warn("[WARN] Web Speech API not supported.");
    }
}

/**
 * Determines the user's skill level based on their best 3x3 solve time.
 * This is a simplified heuristic.
 * @returns {string} 'beginner', 'intermediate', or 'advanced'.
 */
async function getUserLevel() {
    if (!userId) {
        console.warn("[WARN] userId not set for getUserLevel. Defaulting to beginner.");
        return 'beginner';
    }

    if (isUserAuthenticated && db) {
        try {
            const userSettingsRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userSettings`);
            const docSnap = await getDoc(userSettingsRef);

            if (docSnap.exists()) {
                const settings = docSnap.data();
                const bestTime = settings.bestTime3x3; // Assuming bestTime3x3 is stored in milliseconds

                if (bestTime === undefined || bestTime === null) {
                    return 'beginner';
                }

                // Heuristics for skill level (in milliseconds)
                const beginnerThreshold = 60 * 1000; // 1 minute
                const intermediateThreshold = 30 * 1000; // 30 seconds

                if (bestTime > beginnerThreshold) {
                    return 'beginner';
                } else if (bestTime > intermediateThreshold) {
                    return 'intermediate';
                } else {
                    return 'advanced';
                }
            } else {
                console.log("[INFO] No user settings found for skill level determination. Defaulting to beginner.");
                return 'beginner';
            }
        } catch (e) {
            console.error("[ERROR] Error getting user level from Firestore:", e);
            return 'beginner'; // Fallback
        }
    } else {
        // For unauthenticated users, attempt to get best time from local storage if available
        try {
            const localSettings = JSON.parse(localStorage.getItem('cubingTimerSettings'));
            if (localSettings && localSettings.bestTime3x3 !== undefined && localSettings.bestTime3x3 !== null) {
                const bestTime = localSettings.bestTime3x3;
                const beginnerThreshold = 60 * 1000;
                const intermediateThreshold = 30 * 1000;

                if (bestTime > beginnerThreshold) {
                    return 'beginner';
                } else if (bestTime > intermediateThreshold) {
                    return 'intermediate';
                } else {
                    return 'advanced';
                }
            }
        } catch (e) {
            console.error("[ERROR] Error getting user level from localStorage:", e);
        }
        return 'beginner'; // Default for guests or if local storage fails
    }
}

/**
 * Retrieves the current theme's background color in hex format for Twisty-Player.
 * @returns {string} Hex color string (e.g., '#0f172a').
 */
function getThemeBackgroundColorHex() {
    const body = document.body;
    // Get the computed style of the body
    const computedStyle = getComputedStyle(body);
    // Get the value of the CSS variable
    const bgColor = computedStyle.getPropertyValue('--bg-color-primary').trim();

    // Tailwind's default dark theme primary background is #0f172a
    // If the variable isn't set or is transparent, use a fallback
    if (bgColor && bgColor !== 'transparent') {
        return bgColor;
    }

    // Fallback based on known themes
    switch (currentTheme) {
        case 'light':
            return '#f1f5f9'; // Light theme primary background
        case 'vibrant':
            return '#1a1a2e'; // Vibrant theme primary background
        case 'dark':
        default:
            return '#0f172a'; // Dark theme primary background
    }
}


/**
 * Maps internal cube type strings to Twisty-Player puzzle type strings.
 * @param {string} cubeType Internal cube type (e.g., '3x3', 'pyraminx').
 * @returns {string} Twisty-Player puzzle type (e.g., '3x3x3', 'pyraminx').
 */
function getTwistyPlayerPuzzleType(cubeType) {
    switch (cubeType) {
        case '2x2':
            return '2x2x2';
        case '3x3':
            return '3x3x3';
        case '4x4':
            return '4x4x4';
        case 'pyraminx':
            return 'pyraminx';
        // Add more cases as needed
        default:
            return '3x3x3'; // Default to 3x3 if unknown
    }
}

/**
 * Generates a UUID.
 * @returns {string} A new UUID.
 */
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// =====================================================================================================
// --- UI State Management ---
// =====================================================================================================

/**
 * Shows the specified section and hides others.
 * @param {HTMLElement} sectionToShow The section to make visible.
 */
function showSection(sectionToShow) {
    const sections = [lessonHub, lessonChatContainer, lessonDisplayArea, lessonHistorySection];
    sections.forEach(section => {
        if (section) {
            section.classList.add('hidden');
        }
    });
    if (sectionToShow) {
        sectionToShow.classList.remove('hidden');
    }
}

/**
 * Shows or hides the global loading spinner.
 * @param {boolean} show True to show, false to hide.
 */
function showGlobalLoadingSpinner(show) {
    if (globalLoadingSpinner) {
        globalLoadingSpinner.style.display = show ? 'block' : 'none';
    }
}

/**
 * Shows or hides the chat typing indicator.
 * @param {boolean} show True to show, false to hide.
 */
function showTypingIndicator(show) {
    if (chatTypingIndicator) {
        chatTypingIndicator.classList.toggle('hidden', !show);
    }
}

// =====================================================================================================
// --- Firebase & User Data Initialization ---
// =====================================================================================================

/**
 * Initializes Firebase and authenticates the user.
 * This function now mirrors the authentication logic of script.js.
 */
async function initializeFirebaseAndAuth() {
    try {
        app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                // User is signed in (authenticated)
                userId = user.uid;
                isUserAuthenticated = true;
                console.log(`[DEBUG] Firebase Auth: User signed in with UID: ${userId}`);
            } else {
                // No user is signed in. This means it's a guest session.
                // Generate a guest ID for local storage if not already present
                let storedGuestId = localStorage.getItem('guestUserId');
                if (!storedGuestId) {
                    storedGuestId = `guest-${crypto.randomUUID()}`;
                    localStorage.setItem('guestUserId', storedGuestId);
                }
                userId = storedGuestId;
                isUserAuthenticated = false;
                console.log(`[DEBUG] Firebase Auth: No user signed in. Operating as guest with ID: ${userId}`);
            }
            isAuthReady = true;
            console.log("[DEBUG] Firebase Auth state changed. Auth ready.");
            await loadUserSettings(); // Load user settings once auth is ready
            await loadInitialView(); // Determine which view to show initially
        });

        // Attempt to sign in with custom token if available (from main app)
        if (initialAuthToken) {
            try {
                await signInWithCustomToken(auth, initialAuthToken);
                console.log("[DEBUG] Attempted sign in with custom token.");
            } catch (error) {
                console.error("[ERROR] Firebase Auth: Custom token sign-in failed:", error);
                // If custom token fails, onAuthStateChanged will handle the anonymous/guest state
            }
        }
    } catch (e) {
        console.error("[ERROR] lessons.js: Firebase initialization failed:", e);
        // Fallback for when Firebase init fails entirely (e.g., bad config)
        isAuthReady = true;
        let storedGuestId = localStorage.getItem('guestUserId');
        if (!storedGuestId) {
            storedGuestId = `guest-${crypto.randomUUID()}`;
            localStorage.setItem('guestUserId', storedGuestId);
        }
        userId = storedGuestId;
        isUserAuthenticated = false;
        console.warn("[WARN] Firebase failed to initialize. Operating in guest mode with local storage.");
        await loadUserSettings(); // Attempt to load settings from local storage
        await loadInitialView();
    }
}

/**
 * Loads user settings (cube type, theme, best time) from Firestore or localStorage.
 */
async function loadUserSettings() {
    if (!userId) {
        console.warn("[WARN] userId not set during loadUserSettings. Cannot load settings.");
        return;
    }

    if (isUserAuthenticated && db) {
        try {
            const settingsDocRef = doc(db, `artifacts/${appId}/users/${userId}/settings/userSettings`);
            const docSnap = await getDoc(settingsDocRef);

            if (docSnap.exists()) {
                const settings = docSnap.data();
                currentCubeType = settings.cubeType || '3x3';
                currentTheme = settings.theme || 'dark';
                // Apply theme immediately
                document.body.className = `theme-${currentTheme}`;
                console.log(`[DEBUG] Loaded user settings from Firestore: Cube Type: ${currentCubeType}, Theme: ${currentTheme}`);
            } else {
                console.log("[INFO] No user settings found in Firestore. Using defaults.");
                // Save default settings if none exist, but only if authenticated
                await setDoc(settingsDocRef, { cubeType: currentCubeType, theme: currentTheme }, { merge: true });
            }
        } catch (e) {
            console.error("[ERROR] Error loading user settings from Firestore:", e);
            // Fallback to local storage if Firestore read fails
            loadUserSettingsFromLocalStorage();
        }
    } else {
        // If not authenticated, try local storage
        loadUserSettingsFromLocalStorage();
    }
    userLevel = await getUserLevel(); // Determine user level after settings are loaded
}

/**
 * Loads user settings from localStorage (for guests or Firestore fallback).
 */
function loadUserSettingsFromLocalStorage() {
    try {
        const localSettings = JSON.parse(localStorage.getItem('cubingTimerSettings'));
        if (localSettings) {
            currentCubeType = localSettings.cubeType || '3x3';
            currentTheme = localSettings.theme || 'dark';
            document.body.className = `theme-${currentTheme}`;
            console.log(`[DEBUG] Loaded user settings from localStorage: Cube Type: ${currentCubeType}, Theme: ${currentTheme}`);
        } else {
            console.log("[INFO] No user settings found in localStorage. Using defaults.");
        }
    } catch (e) {
        console.error("[ERROR] Error loading user settings from localStorage:", e);
    }
}

// =====================================================================================================
// --- Lesson History Management ---
// =====================================================================================================

/**
 * Loads and displays the user's lesson history.
 */
async function loadLessonHistory() {
    showGlobalLoadingSpinner(true);
    showSection(lessonHistorySection);
    lessonHistoryList.innerHTML = ''; // Clear existing list
    noLessonsMessage.classList.add('hidden');
    historyLoadingSpinner.style.display = 'block';

    let lessons = [];
    if (isUserAuthenticated && db) {
        try {
            const lessonsCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/lessonHistory`);
            // Order by lastAccessed or creationDate, descending
            const q = query(lessonsCollectionRef, orderBy("lastAccessed", "desc"));
            const querySnapshot = await getDocs(q);
            lessons = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            console.log(`[DEBUG] Loaded ${lessons.length} lessons from Firestore history.`);
        } catch (e) {
            console.error("[ERROR] Error loading lesson history from Firestore:", e);
            showToast("Failed to load lesson history from cloud. Showing local history.", "error");
            lessons = loadLessonHistoryFromLocalStorage();
        }
    } else {
        lessons = loadLessonHistoryFromLocalStorage();
    }

    historyLoadingSpinner.style.display = 'none';

    if (lessons.length === 0) {
        noLessonsMessage.classList.remove('hidden');
    } else {
        lessons.forEach(lesson => {
            const listItem = document.createElement('li');
            listItem.className = 'lesson-history-item bg-gray-700 p-4 rounded-lg flex flex-col sm:flex-row justify-between items-start sm:items-center shadow-md';
            const statusClass = lesson.status === 'completed' ? 'text-green-400' : 'text-yellow-400';
            const lastAccessedDate = lesson.lastAccessed ? new Date(lesson.lastAccessed).toLocaleString() : 'N/A';

            listItem.innerHTML = `
                <div>
                    <h4 class="text-lg font-semibold text-white">${lesson.lessonTitle || 'Untitled Lesson'}</h4>
                    <p class="text-gray-400 text-sm">Cube: ${lesson.cubeType || 'N/A'} | Status: <span class="${statusClass}">${lesson.status || 'In Progress'}</span></p>
                    <p class="text-gray-400 text-xs">Last Accessed: ${lastAccessedDate}</p>
                </div>
                <div class="flex gap-2 mt-3 sm:mt-0">
                    <button class="button-secondary button-small resume-lesson-btn" data-lesson-id="${lesson.id}">
                        <i class="fas ${lesson.status === 'completed' ? 'fa-eye' : 'fa-play'} mr-1"></i> ${lesson.status === 'completed' ? 'Review' : 'Resume'}
                    </button>
                    <button class="button-danger button-small delete-lesson-btn" data-lesson-id="${lesson.id}">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                </div>
            `;
            lessonHistoryList.appendChild(listItem);
        });

        // Attach event listeners to newly created buttons
        lessonHistoryList.querySelectorAll('.resume-lesson-btn').forEach(button => {
            button.addEventListener('click', (event) => {
                const lessonId = event.currentTarget.dataset.lessonId;
                resumeLesson(lessonId);
            });
        });
        lessonHistoryList.querySelectorAll('.delete-lesson-btn').forEach(button => {
            button.addEventListener('click', (event) => {
                const lessonId = event.currentTarget.dataset.lessonId;
                // IMPORTANT: Do NOT use confirm(). Replace with custom modal later.
                if (confirm("Are you sure you want to delete this lesson from your history?")) {
                    deleteLessonFromHistory(lessonId);
                }
            });
        });
    }
    showGlobalLoadingSpinner(false);
}

/**
 * Loads lesson history from localStorage.
 * @returns {Array} Array of lesson history metadata.
 */
function loadLessonHistoryFromLocalStorage() {
    try {
        // Use userId as part of the key for local storage to allow multiple guest users on the same browser
        const localHistoryKey = `cubingLessonHistory_${userId}`;
        const localHistory = JSON.parse(localStorage.getItem(localHistoryKey)) || [];
        return localHistory;
    } catch (e) {
        console.error("[ERROR] Error loading lesson history from localStorage:", e);
        return [];
    }
}

/**
 * Saves lesson history metadata (title, status, etc.) to Firestore or localStorage.
 * @param {Object} lessonMetadata The metadata object for the lesson.
 */
async function saveLessonHistoryMetadata(lessonMetadata) {
    if (!userId) {
        console.warn("[WARN] userId not set during saveLessonHistoryMetadata. Cannot save.");
        return;
    }

    if (isUserAuthenticated && db) {
        try {
            const lessonDocRef = doc(db, `artifacts/${appId}/users/${userId}/lessonHistory`, lessonMetadata.id);
            await setDoc(lessonDocRef, lessonMetadata, { merge: true });
            console.log(`[DEBUG] Saved lesson metadata to Firestore: ${lessonMetadata.id}`);
        } catch (e) {
            console.error("[ERROR] Error saving lesson metadata to Firestore:", e);
            showToast("Failed to save lesson progress to cloud. Saving locally.", "error");
            saveLessonHistoryMetadataToLocalStorage(lessonMetadata);
        }
    } else {
        saveLessonHistoryMetadataToLocalStorage(lessonMetadata);
    }
}

/**
 * Saves lesson history metadata to localStorage.
 * @param {Object} lessonMetadata The metadata object for the lesson.
 */
function saveLessonHistoryMetadataToLocalStorage(lessonMetadata) {
    try {
        const localHistoryKey = `cubingLessonHistory_${userId}`;
        let localHistory = JSON.parse(localStorage.getItem(localHistoryKey)) || [];
        const existingIndex = localHistory.findIndex(l => l.id === lessonMetadata.id);
        if (existingIndex > -1) {
            localHistory[existingIndex] = { ...localHistory[existingIndex], ...lessonMetadata };
        } else {
            localHistory.push(lessonMetadata);
        }
        localStorage.setItem(localHistoryKey, JSON.stringify(localHistory));
        console.log(`[DEBUG] Saved lesson metadata to localStorage: ${lessonMetadata.id}`);
    } catch (e) {
        console.error("[ERROR] Error saving lesson metadata to localStorage:", e);
    }
}

/**
 * Deletes a lesson from history.
 * @param {string} lessonId The ID of the lesson to delete.
 */
async function deleteLessonFromHistory(lessonId) {
    showGlobalLoadingSpinner(true);
    if (!userId) {
        console.warn("[WARN] userId not set during deleteLessonFromHistory. Cannot delete.");
        showGlobalLoadingSpinner(false);
        return;
    }

    if (isUserAuthenticated && db) {
        try {
            const lessonDocRef = doc(db, `artifacts/${appId}/users/${userId}/lessonHistory`, lessonId);
            await deleteDoc(lessonDocRef);
            console.log(`[DEBUG] Deleted lesson ${lessonId} from Firestore.`);
            showToast("Lesson deleted successfully.", "success");
        } catch (e) {
            console.error(`[ERROR] Error deleting lesson ${lessonId} from Firestore:`, e);
            showToast("Failed to delete lesson from cloud. Deleting locally.", "error");
            deleteLessonFromHistoryLocalStorage(lessonId);
        }
    } else {
        deleteLessonFromHistoryLocalStorage(lessonId);
    }
    await loadLessonHistory(); // Reload history to update UI
    showGlobalLoadingSpinner(false);
}

/**
 * Deletes a lesson from localStorage.
 * @param {string} lessonId The ID of the lesson to delete.
 */
function deleteLessonFromHistoryLocalStorage(lessonId) {
    try {
        const localHistoryKey = `cubingLessonHistory_${userId}`;
        let localHistory = JSON.parse(localStorage.getItem(localHistoryKey)) || [];
        localHistory = localHistory.filter(lesson => lesson.id !== lessonId);
        localStorage.setItem(localHistoryKey, JSON.stringify(localHistory));
        console.log(`[DEBUG] Deleted lesson ${lessonId} from localStorage.`);
    } catch (e) {
        console.error("[ERROR] Error deleting lesson from localStorage:", e);
    }
}

/**
 * Resumes a previously started or completed lesson.
 * @param {string} lessonId The ID of the lesson to resume.
 */
async function resumeLesson(lessonId) {
    showGlobalLoadingSpinner(true);
    let lessonData = null;
    let lessonProgress = null;

    if (!userId) {
        console.warn("[WARN] userId not set during resumeLesson. Cannot resume.");
        showToast("Cannot resume lesson: User ID not available.", "error");
        showSection(lessonHub);
        showGlobalLoadingSpinner(false);
        return;
    }

    if (isUserAuthenticated && db) {
        try {
            const lessonDocRef = doc(db, `artifacts/${appId}/users/${userId}/lessonHistory`, lessonId);
            const docSnap = await getDoc(lessonDocRef);

            if (docSnap.exists()) {
                lessonData = docSnap.data();
                // Firestore automatically handles nested objects/arrays, so no JSON.parse needed for steps
                // However, if `completedSteps` was stored as a JSON string, parse it.
                lessonProgress = lessonData.completedSteps ? new Set(JSON.parse(lessonData.completedSteps)) : new Set();
                console.log(`[DEBUG] Resumed lesson ${lessonId} from Firestore.`);
            }
        } catch (e) {
            console.error(`[ERROR] Error resuming lesson ${lessonId} from Firestore:`, e);
            showToast("Failed to resume lesson from cloud. Attempting local data.", "error");
        }
    }

    if (!lessonData) { // Fallback to local storage if Firestore failed or no data
        const localHistoryKey = `cubingLessonHistory_${userId}`;
        const localHistory = JSON.parse(localStorage.getItem(localHistoryKey)) || [];
        lessonData = localHistory.find(l => l.id === lessonId);
        if (lessonData) {
            lessonProgress = lessonData.completedSteps ? new Set(JSON.parse(lessonData.completedSteps)) : new Set();
            console.log(`[DEBUG] Resumed lesson ${lessonId} from localStorage.`);
        }
    }

    if (lessonData) {
        currentLesson = lessonData;
        completedSteps = lessonProgress;
        // Find the first incomplete step, or default to 0 if all complete
        currentLessonStepIndex = 0;
        for (let i = 0; i < currentLesson.steps.length; i++) {
            if (!completedSteps.has(i)) {
                currentLessonStepIndex = i;
                break;
            }
        }
        displayGeneratedLesson(currentLesson); // Display the lesson at the determined step
        showGlobalLoadingSpinner(false);
    } else {
        showToast("Lesson not found or failed to load.", "error");
        showSection(lessonHub); // Go back to hub if lesson not found
        showGlobalLoadingSpinner(false);
    }
}


/**
 * Saves the completion status of steps for the current lesson.
 * @param {string} lessonId The ID of the lesson.
 * @param {Set<number>} stepsCompleted A Set of completed step indices.
 */
async function saveLessonProgress(lessonId, stepsCompleted) {
    const progressData = JSON.stringify(Array.from(stepsCompleted)); // Convert Set to Array string for storage

    if (!userId) {
        console.warn("[WARN] userId not set during saveLessonProgress. Cannot save.");
        return;
    }

    if (isUserAuthenticated && db) {
        try {
            const lessonDocRef = doc(db, `artifacts/${appId}/users/${userId}/lessonHistory`, lessonId);
            await updateDoc(lessonDocRef, {
                completedSteps: progressData,
                status: stepsCompleted.size === currentLesson.steps.length ? 'completed' : 'in_progress',
                lastAccessed: Date.now() // Update last accessed time
            });
            console.log(`[DEBUG] Saved lesson progress for ${lessonId} to Firestore.`);
        } catch (e) {
            console.error(`[ERROR] Error saving lesson progress for ${lessonId} to Firestore:`, e);
            showToast("Failed to save lesson progress to cloud. Saving locally.", "error");
            saveLessonProgressToLocalStorage(lessonId, progressData);
        }
    } else {
        saveLessonProgressToLocalStorage(lessonId, progressData);
    }
}

/**
 * Saves the completion status of steps for the current lesson to localStorage.
 * @param {string} lessonId The ID of the lesson.
 * @param {string} progressData JSON string of completed step indices.
 */
function saveLessonProgressToLocalStorage(lessonId, progressData) {
    try {
        const localHistoryKey = `cubingLessonHistory_${userId}`;
        let localHistory = JSON.parse(localStorage.getItem(localHistoryKey)) || [];
        const lessonIndex = localHistory.findIndex(l => l.id === lessonId);
        if (lessonIndex > -1) {
            localHistory[lessonIndex].completedSteps = progressData;
            localHistory[lessonIndex].status = JSON.parse(progressData).length === currentLesson.steps.length ? 'completed' : 'in_progress';
            localHistory[lessonIndex].lastAccessed = Date.now();
        }
        localStorage.setItem(localHistoryKey, JSON.stringify(localHistory));
        console.log(`[DEBUG] Saved lesson progress for ${lessonId} to localStorage.`);
    } catch (e) {
        console.error("[ERROR] Error saving lesson progress to localStorage:", e);
    }
}


// =====================================================================================================
// --- Conversational Chat Logic ---
// =====================================================================================================

/**
 * Appends a message to the chat display.
 * @param {string} sender 'user' or 'jarvis'.
 * @param {string} message The message text.
 */
function appendChatMessage(sender, message) {
    const messageDiv = document.createElement('div');
    messageDiv.className = `p-3 rounded-lg max-w-[80%] my-2 ${sender === 'user' ? 'bg-indigo-600 text-white self-end ml-auto' : 'bg-gray-600 text-gray-100 self-start mr-auto'}`;
    messageDiv.innerHTML = `
        <p class="font-semibold mb-1">${sender === 'user' ? 'You' : 'Jarvis'}</p>
        <p>${message}</p>
    `;
    chatMessagesDisplay.appendChild(messageDiv);
    chatMessagesDisplay.scrollTop = chatMessagesDisplay.scrollHeight; // Auto-scroll to bottom
}

/**
 * Sends the user's chat message to the AI backend.
 */
async function sendLessonChatToAI() {
    const userMessage = lessonChatInput.value.trim();
    if (!userMessage) return;

    appendChatMessage('user', userMessage);
    backendChatHistory.push({ role: "user", parts: [{ text: userMessage }] });
    lessonChatInput.value = ''; // Clear input

    showTypingIndicator(true);
    sendLessonChatBtn.disabled = true;
    lessonChatInput.disabled = true;

    try {
        let payload;
        let apiUrl = `/api/gemini-insight`; // Vercel serverless function endpoint

        if (isAwaitingLessonGenerationConfirmation) {
            // User is confirming lesson generation
            const confirmationKeywords = ['yes', 'confirm', 'proceed', 'sure', 'ok']; // Expanded keywords
            if (confirmationKeywords.some(keyword => userMessage.toLowerCase().includes(keyword))) {
                console.log("[DEBUG] User confirmed lesson generation.");
                isAwaitingLessonGenerationConfirmation = false;
                requestFinalLessonFromAI(); // Call the function to generate the final lesson
                return; // Exit here as requestFinalLessonFromAI will handle its own loading/UI
            } else {
                appendChatMessage('jarvis', "Pardon me, Sir Sevindu. Did you wish to proceed with the lesson generation? Please confirm with 'yes' or 'confirm' if so, or continue our conversation.");
                speakAsJarvis("Pardon me, Sir Sevindu. Did you wish to proceed with the lesson generation? Please confirm with 'yes' or 'confirm' if so, or continue our conversation.");
                showTypingIndicator(false);
                sendLessonChatBtn.disabled = false;
                lessonChatInput.disabled = false;
                return; // Exit as no AI call is needed for this non-confirmation response
            }
        }

        // Normal conversational turn
        payload = {
            type: "lesson_chat",
            chatHistory: backendChatHistory,
            cubeType: currentCubeType,
            userLevel: userLevel
        };

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        const aiMessage = result.message;

        // Check for the lesson generation readiness marker
        const lessonReadyMarker = "[LESSON_PLAN_PROPOSAL_READY]";
        let displayMessage = aiMessage;
        if (aiMessage.includes(lessonReadyMarker)) {
            displayMessage = aiMessage.replace(lessonReadyMarker, '').trim();
            isAwaitingLessonGenerationConfirmation = true;
            appendChatMessage('jarvis', displayMessage + " I believe I have sufficient information to generate your personalized lesson. Shall I proceed, Sir Sevindu?");
            speakAsJarvis(displayMessage + " I believe I have sufficient information to generate your personalized lesson. Shall I proceed, Sir Sevindu?");
        } else {
            appendChatMessage('jarvis', displayMessage);
            speakAsJarvis(displayMessage);
        }

        backendChatHistory.push({ role: "model", parts: [{ text: aiMessage }] }); // Store original AI message for context

    } catch (error) {
        console.error("[ERROR] Error communicating with AI for lesson chat:", error);
        appendChatMessage('jarvis', `My apologies, Sir Sevindu. I encountered an error: ${error.message}. Please try again.`);
        speakAsJarvis(`My apologies, Sir Sevindu. I encountered an error: ${error.message}. Please try again.`);
        showToast(`AI Error: ${error.message}`, 'error');
    } finally {
        showTypingIndicator(false);
        sendLessonChatBtn.disabled = false;
        lessonChatInput.disabled = false;
        lessonChatInput.focus();
    }
}

/**
 * Requests the final structured lesson from the AI.
 */
async function requestFinalLessonFromAI() {
    showSection(null); // Hide all sections
    showGlobalLoadingSpinner(true);
    showToast("Generating your personalized lesson, Sir Sevindu...", "info");
    speakAsJarvis("Generating your personalized lesson, Sir Sevindu. This may take a moment.");

    try {
        const payload = {
            type: "generate_final_lesson",
            chatHistory: backendChatHistory, // Send full history for context
            cubeType: currentCubeType,
            userLevel: userLevel
        };

        const apiUrl = `/api/gemini-insight`;

        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        currentLesson = result.lessonData;
        currentLesson.id = currentLesson.id || generateUUID(); // Ensure lesson has an ID
        currentLesson.createdAt = Date.now();
        currentLesson.lastAccessed = Date.now();
        currentLesson.status = 'in_progress';
        currentLesson.cubeType = currentCubeType; // Ensure cube type is saved with lesson metadata

        completedSteps = new Set(); // Reset completed steps for new lesson
        await saveLessonHistoryMetadata(currentLesson); // Save initial lesson metadata

        displayGeneratedLesson(currentLesson);
        showToast("Lesson generated successfully!", "success");
        speakAsJarvis(`Your lesson, titled "${currentLesson.lessonTitle}", is now ready, Sir Sevindu.`);

    } catch (error) {
        console.error("[ERROR] Error generating final lesson:", error);
        showToast(`Failed to generate lesson: ${error.message}`, 'error');
        speakAsJarvis(`My apologies, Sir Sevindu. I was unable to generate the lesson due to an error: ${error.message}. Please try again.`);
        showSection(lessonChatContainer); // Go back to chat if generation fails
        appendChatMessage('jarvis', `I encountered an issue generating the lesson: ${error.message}. Please refine your request or try again.`);
    } finally {
        showGlobalLoadingSpinner(false);
    }
}

// =====================================================================================================
// --- Lesson Display Logic ---
// =====================================================================================================

/**
 * Displays the generated lesson.
 * @param {Object} lesson The lesson object.
 */
function displayGeneratedLesson(lesson) {
    currentLesson = lesson;
    lessonTitleDisplay.textContent = lesson.lessonTitle;
    showSection(lessonDisplayArea);
    displayLessonStep(currentLessonStepIndex);
}

/**
 * Displays a specific step of the current lesson.
 * @param {number} index The index of the step to display.
 */
function displayLessonStep(index) {
    if (!currentLesson || !currentLesson.steps || index < 0 || index >= currentLesson.steps.length) {
        console.error("[ERROR] Invalid lesson step index or no current lesson.");
        showToast("Error displaying lesson step.", "error");
        return;
    }

    currentLessonStepIndex = index;
    const step = currentLesson.steps[currentLessonStepIndex];

    lessonStepTitleDisplay.textContent = step.title;
    lessonStepDescriptionDisplay.textContent = step.description;
    lessonExplanationDisplay.textContent = step.explanation;

    // Twisty Player setup
    if (twistyPlayerLessonViewer) {
        twistyPlayerLessonViewer.puzzle = getTwistyPlayerPuzzleType(currentCubeType);
        twistyPlayerLessonViewer.alg = ''; // Clear previous alg
        twistyPlayerLessonViewer.experimentalSetupAlg = ''; // Clear previous setup alg
        twistyPlayerLessonViewer.camera = 'plan'; // Default camera view

        // Set background color based on theme
        twistyPlayerLessonViewer.style.setProperty('--twisty-player-background', getThemeBackgroundColorHex());

        if (step.scramble) {
            twistyPlayerLessonViewer.alg = step.scramble;
            lessonScrambleCubeBtn.style.display = 'inline-block';
            lessonVisualContainer.style.display = 'block';
            speakAsJarvis(`Step ${index + 1}: ${step.title}. Here is the scramble.`);
        } else {
            lessonScrambleCubeBtn.style.display = 'none';
        }

        if (step.algorithm) {
            twistyPlayerLessonViewer.alg = step.algorithm;
            lessonSolveCubeBtn.style.display = 'inline-block';
            lessonVisualContainer.style.display = 'block';
            speakAsJarvis(`Step ${index + 1}: ${step.title}. Here is the algorithm.`);
        } else {
            lessonSolveCubeBtn.style.display = 'none';
        }

        if (!step.scramble && !step.algorithm) {
            lessonVisualContainer.style.display = 'none'; // Hide if no visual component
            speakAsJarvis(`Step ${index + 1}: ${step.title}. ${step.description}`);
        }

        // Corrected: Use pause() instead of stop()
        lessonPlayBtn.style.display = 'inline-block';
        lessonPauseBtn.style.display = 'none';
        twistyPlayerLessonViewer.pause(); // Pause any ongoing animation

    } else {
        console.warn("[WARN] Twisty Player element not found.");
    }

    updateNavigationButtons();
    updateLessonProgressBar();
    updateMarkStepCompleteButton();
    updateCompleteLessonButton();
}

/**
 * Updates the state of the navigation buttons (Previous, Next).
 */
function updateNavigationButtons() {
    if (prevLessonStepBtn) {
        prevLessonStepBtn.disabled = currentLessonStepIndex === 0;
    }
    if (nextLessonStepBtn) {
        nextLessonStepBtn.disabled = !currentLesson || currentLessonStepIndex >= currentLesson.steps.length - 1;
    }
    if (lessonStepCounter) {
        lessonStepCounter.textContent = `Step ${currentLessonStepIndex + 1} of ${currentLesson ? currentLesson.steps.length : 0}`;
    }
}

/**
 * Updates the lesson progress bar.
 */
function updateLessonProgressBar() {
    if (lessonProgressBar && currentLesson && currentLesson.steps.length > 0) {
        const progress = (completedSteps.size / currentLesson.steps.length) * 100;
        lessonProgressBar.style.width = `${progress}%`;
    }
}

/**
 * Updates the 'Mark Step Complete' button's text and state.
 */
function updateMarkStepCompleteButton() {
    if (markStepCompleteBtn) {
        if (completedSteps.has(currentLessonStepIndex)) {
            markStepCompleteBtn.textContent = 'Step Completed';
            markStepCompleteBtn.disabled = true;
            markStepCompleteBtn.classList.remove('button-secondary');
            markStepCompleteBtn.classList.add('button-success');
            markStepCompleteBtn.style.display = 'block';
        } else {
            markStepCompleteBtn.textContent = 'Mark Step Complete';
            markStepCompleteBtn.disabled = false;
            markStepCompleteBtn.classList.remove('button-success');
            markStepCompleteBtn.classList.add('button-secondary');
            markStepCompleteBtn.style.display = 'block';
        }
        // Hide if it's the last step and all steps are complete, and the complete lesson button is shown
        if (currentLessonStepIndex === currentLesson.steps.length - 1 && completedSteps.size === currentLesson.steps.length) {
            markStepCompleteBtn.style.display = 'none';
        }
    }
}

/**
 * Updates the visibility of the 'Complete Lesson' button.
 */
function updateCompleteLessonButton() {
    if (completeLessonBtn) {
        if (currentLesson && completedSteps.size === currentLesson.steps.length && currentLesson.steps.length > 0) {
            completeLessonBtn.style.display = 'block';
        } else {
            completeLessonBtn.style.display = 'none';
        }
    }
    if (lessonCompletionMessage) {
        lessonCompletionMessage.style.display = 'none'; // Hide message initially
    }
}

/**
 * Marks the current lesson step as complete.
 */
async function markStepComplete() {
    if (!currentLesson || completedSteps.has(currentLessonStepIndex)) {
        return; // Already complete or no lesson
    }

    completedSteps.add(currentLessonStepIndex);
    await saveLessonProgress(currentLesson.id, completedSteps);

    updateMarkStepCompleteButton();
    updateLessonProgressBar();
    updateCompleteLessonButton();
    showToast("Step marked as complete!", "success");
    speakAsJarvis("Excellent, Sir Sevindu. Step marked as complete.");

    // Automatically advance to next step if not the last
    if (currentLessonStepIndex < currentLesson.steps.length - 1) {
        setTimeout(() => {
            displayLessonStep(currentLessonStepIndex + 1);
        }, 500); // Small delay for visual feedback
    }
}

/**
 * Marks the entire lesson as complete.
 */
async function completeLesson() {
    if (!currentLesson) return;

    // Ensure all steps are marked complete
    for (let i = 0; i < currentLesson.steps.length; i++) {
        completedSteps.add(i);
    }
    await saveLessonProgress(currentLesson.id, completedSteps); // Save final state

    if (lessonCompletionMessage) {
        lessonCompletionMessage.textContent = `Congratulations, Sir Sevindu! You have successfully completed the lesson "${currentLesson.lessonTitle}"!`;
        lessonCompletionMessage.style.display = 'block';
    }
    if (completeLessonBtn) completeLessonBtn.style.display = 'none';
    if (markStepCompleteBtn) markStepCompleteBtn.style.display = 'none'; // Hide step complete button too

    showToast("Lesson completed!", "success");
    speakAsJarvis(`Congratulations, Sir Sevindu! You have successfully completed the lesson "${currentLesson.lessonTitle}"!`);

    // Offer options to go back to hub or history
    setTimeout(() => {
        showSection(lessonHub);
        // Reset chat history for next new lesson
        lessonChatHistory = [];
        backendChatHistory = [];
        chatMessagesDisplay.innerHTML = `
            <div class="text-center text-gray-400 italic">
                <p>Jarvis is ready to assist you, Sir Sevindu.</p>
            </div>
        `;
    }, 5000); // Go back to hub after 5 seconds
}


// =====================================================================================================
// --- Event Listeners and Initial Page Setup ---
// =====================================================================================================

/**
 * Assigns DOM elements and sets up event listeners.
 */
function setupEventListeners() {
    // Hub elements
    lessonHub = document.getElementById('lessonHub');
    startNewLessonBtn = document.getElementById('startNewLessonBtn');
    viewLessonHistoryBtn = document.getElementById('viewLessonHistoryBtn');

    // Chat elements
    lessonChatContainer = document.getElementById('lessonChatContainer');
    chatMessagesDisplay = document.getElementById('chatMessagesDisplay');
    lessonChatInput = document.getElementById('lessonChatInput');
    sendLessonChatBtn = document.getElementById('sendLessonChatBtn');
    chatTypingIndicator = document.getElementById('chatTypingIndicator');

    // Lesson Display elements
    lessonDisplayArea = document.getElementById('lessonDisplayArea');
    lessonTitleDisplay = document.getElementById('lessonTitleDisplay');
    lessonProgressBar = document.getElementById('lessonProgressBar');
    lessonStepTitleDisplay = document.getElementById('lessonStepTitleDisplay');
    lessonStepDescriptionDisplay = document.getElementById('lessonStepDescriptionDisplay');
    lessonVisualContainer = document.getElementById('lessonVisualContainer');
    twistyPlayerLessonViewer = document.getElementById('twistyPlayerLessonViewer');
    lessonExplanationDisplay = document.getElementById('lessonExplanationDisplay');
    markStepCompleteBtn = document.getElementById('markStepCompleteBtn');
    prevLessonStepBtn = document.getElementById('prevLessonStepBtn');
    lessonStepCounter = document.getElementById('lessonStepCounter');
    nextLessonStepBtn = document.getElementById('nextLessonStepBtn');
    completeLessonBtn = document.getElementById('completeLessonBtn');
    lessonCompletionMessage = document.getElementById('lessonCompletionMessage');

    // Twisty Player controls
    lessonPlayBtn = document.getElementById('lessonPlayBtn');
    lessonPauseBtn = document.getElementById('lessonPauseBtn');
    lessonResetViewBtn = document.getElementById('lessonResetViewBtn');
    lessonScrambleCubeBtn = document.getElementById('lessonScrambleCubeBtn');
    lessonSolveCubeBtn = document.getElementById('lessonSolveCubeBtn');

    // History elements
    lessonHistorySection = document.getElementById('lessonHistorySection');
    lessonHistoryList = document.getElementById('lessonHistoryList');
    noLessonsMessage = document.getElementById('noLessonsMessage');
    historyLoadingSpinner = document.getElementById('historyLoadingSpinner');

    // Global spinner
    globalLoadingSpinner = document.getElementById('globalLoadingSpinner');


    // --- Event Listeners ---
    if (startNewLessonBtn) {
        startNewLessonBtn.addEventListener('click', () => {
            showSection(lessonChatContainer);
            // Initial Jarvis message to guide the user
            appendChatMessage('jarvis', "Greetings, Sir Sevindu. I am Jarvis, your AI cubing instructor. How may I assist you with your cubing journey today? Please tell me what you wish to learn, your current understanding, and any specific areas you wish to focus upon.");
            speakAsJarvis("Greetings, Sir Sevindu. I am Jarvis, your AI cubing instructor. How may I assist you with your cubing journey today? Please tell me what you wish to learn, your current understanding, and any specific areas you wish to focus upon.");
            lessonChatInput.focus();
        });
    }

    if (viewLessonHistoryBtn) {
        viewLessonHistoryBtn.addEventListener('click', () => {
            loadLessonHistory();
        });
    }

    if (sendLessonChatBtn) {
        sendLessonChatBtn.addEventListener('click', sendLessonChatToAI);
    }

    if (lessonChatInput) {
        lessonChatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendLessonChatToAI();
            }
        });
    }

    if (prevLessonStepBtn) {
        prevLessonStepBtn.addEventListener('click', () => {
            if (currentLessonStepIndex > 0) {
                displayLessonStep(currentLessonStepIndex - 1);
            }
        });
    }

    if (nextLessonStepBtn) {
        nextLessonStepBtn.addEventListener('click', () => {
            if (currentLesson && currentLessonStepIndex < currentLesson.steps.length - 1) {
                displayLessonStep(currentLessonStepIndex + 1);
            }
        });
    }

    if (markStepCompleteBtn) {
        markStepCompleteBtn.addEventListener('click', markStepComplete);
    }

    if (completeLessonBtn) {
        completeLessonBtn.addEventListener('click', completeLesson);
    }

    // Twisty Player Controls
    if (lessonPlayBtn) lessonPlayBtn.addEventListener('click', () => {
        if (twistyPlayerLessonViewer) {
            twistyPlayerLessonViewer.play();
            lessonPlayBtn.style.display = 'none';
            lessonPauseBtn.style.display = 'inline-block';
        }
    });

    if (lessonPauseBtn) lessonPauseBtn.addEventListener('click', () => {
        if (twistyPlayerLessonViewer) {
            twistyPlayerLessonViewer.pause();
            lessonPlayBtn.style.display = 'inline-block';
            lessonPauseBtn.style.display = 'none';
        }
    });

    // FIX: Replaced .resetView() with .alg = '' as .resetView() is not a function in twisty-player
    if (lessonResetViewBtn) lessonResetViewBtn.addEventListener('click', () => {
        if (twistyPlayerLessonViewer) {
            twistyPlayerLessonViewer.alg = ''; // Clear the algorithm/scramble
            // If twistyPlayerLessonViewer.reset() exists and is desired for camera reset, keep it.
            // Otherwise, removing it is safer to avoid potential errors.
            // twistyPlayerLessonViewer.reset(); 
            speakAsJarvis("Twisty Player view has been reset, Sir Sevindu.");
        }
    });

    if (lessonScrambleCubeBtn) lessonScrambleCubeBtn.addEventListener('click', () => {
        if (twistyPlayerLessonViewer && currentLesson && currentLesson.steps[currentLessonStepIndex] && currentLesson.steps[currentLessonStepIndex].scramble) {
            twistyPlayerLessonViewer.alg = currentLesson.steps[currentLessonStepIndex].scramble;
            twistyPlayerLessonViewer.play();
            lessonPlayBtn.style.display = 'none';
            lessonPauseBtn.style.display = 'inline-block';
        } else {
            speakAsJarvis("Pardon me, Sir Sevindu. This step does not have a specific scramble to apply.");
        }
    });

    if (lessonSolveCubeBtn) lessonSolveCubeBtn.addEventListener('click', () => {
        if (twistyPlayerLessonViewer && currentLesson && currentLesson.steps[currentLessonStepIndex] && currentLesson.steps[currentLessonStepIndex].algorithm) {
            twistyPlayerLessonViewer.alg = currentLesson.steps[currentLessonStepIndex].algorithm;
            twistyPlayerLessonViewer.play();
            lessonPlayBtn.style.display = 'none';
            lessonPauseBtn.style.display = 'inline-block';
        } else {
            speakAsJarvis("Pardon me, Sir Sevindu. This step does not have a specific algorithm to demonstrate the solve.");
        }
    });
}

/**
 * Determines which section to show initially based on user state or last activity.
 */
async function loadInitialView() {
    // For now, always start at the hub. In a more complex app,
    // we might check if a lesson was in progress and resume it directly.
    showSection(lessonHub);
    showGlobalLoadingSpinner(false); // Hide global spinner once initial view is set
}


/**
 * Initializes the lessons page by setting up DOM elements and Firebase.
 */
document.addEventListener('DOMContentLoaded', () => {
    console.log("[DEBUG] lessons.js: DOMContentLoaded triggered. Assigning DOM elements and initializing.");
    setupEventListeners(); // Assign DOM elements and add listeners
    initializeFirebaseAndAuth(); // Initialize Firebase and authentication
});
